---
tags:
- tech/cpp/scheduler/cgraph
- blog
date: '2024-12-25 00:00:00'
title: CGraph调研
---

# CGraph调研

repo：https://github.com/ChunelFeng/CGraph

## 功能

### 建立依赖图关系：GPipeline、GNode（T00/T01）

- 一条 pipeline 是从头执行到尾的，其实是 graph 的概念，没有流水线的功能

```C++
status += pipeline->registerGElement<MyNode2>(&b, {a}, "nodeB");    // 将名为nodeB，依赖a执行的node信息，注册入pipeline中
```

### 子图：Cluster / Region：类似 subgraph，互相可嵌套（T02/T03/T04）

- cluster：subgraph 中的多个节点串行执行

> http://www.chunel.cn/archives/cgraph-run-introduce
![|434](assets/Pasted%20image%2020241225154105.png)
![|588](assets/Pasted%20image%2020241225154201.png)
> - 这个解释感觉有点奇怪，D/F 未能并行执行是实现机制的问题，感觉不需要引入新的概念来解决。

- region：可以是 DAG 图

```C++
b_cluster = pipeline->createGGroup<GCluster>({
	 pipeline->createGNode<MyNode1>(GNodeInfo("nodeB1", 1)),    // 创建名为nodeB1的node信息，并将其放入b_cluster中
	 pipeline->createGNode<MyNode1>(GNodeInfo("nodeB2", 3)),    // 创建名为nodeB2且自循环3次的node信息，并将其放入b_cluster中
	 pipeline->createGNode<MyNode2>(GNodeInfo("nodeB3", 1))
});    // 创建cluster信息，包含了三个node信息
```

```C++
    b_region = pipeline->createGGroup<GRegion>({b1, b2, b3, b4});    // 将 b1、b2、b3、b4 注册入b_region中
```

### 参数传递：param (T05)

相当于是一个 map，同一个 pipeline 中各个节点共享的全局参数。

```C++
// 创建
status = CGRAPH_CREATE_GPARAM(MyParam, "param1")

// 读取
auto* myParam = CGRAPH_GET_GPARAM_WITH_NO_EMPTY(MyParam, "param1")

// 写入
CGRAPH_PARAM_WRITE_CODE_BLOCK(myParam)
```

### 条件选择：Condition （T06）

根据 `choose` 返回值，来决定下一步运行哪一个节点。

choose 函数里，可以通过 param 来获取到外界信息，做一些判断。

```C++
b_condition = pipeline->createGGroup<MyCondition>({
	pipeline->createGNode<MyNode1>(GNodeInfo("conditionNodeB0", 1)),
	pipeline->createGNode<MyNode2>(GNodeInfo("conditionNodeB1", 1)),
	pipeline->createGNode<MyNode1>(GNodeInfo("conditionNodeB2", 1))
});    // 生成 b_condition。执行的时候，根据choose()的返回值，在B0,B1,B2中选择一个执行
```

### 多条 pipeline (T07)

- 手动指定线程池

```C++
// 创建线程池
UThreadPoolConfig config;
config.default_thread_size_ = 4;
config.max_thread_size_ = 4;
config.monitor_enable_ = false;
UThreadPool pool(true, config);    // 开辟一个4个线程的线程池，直接 init，并且参数设置为 config

// 指定pipeline使用的线程池
pipeline_1->setSharedThreadPool(&pool);

// 多个pipeline，可以共享同一个线程池
pipeline_2->setSharedThreadPool(&pool);
```

- 异步执行 n 次：
    - 只是包装了一下 std::async，没有其他特殊处理

```C++
    return pipeline_1->asyncProcess(5); // std::future<CStatus>
```

### 有初始化参数的 GNode (T08)

- 会用传入的参数，初始化这个 node。

```C++
pipeline->registerGElement<MyTemplateNode<int, float>>(&a, {}, 3, 3.5f);
```

### 切面 GAspect ：（T09/T10）

- Observer，可以在几个执行点前后（init/run/destroy）插入逻辑。

```C++
    a->addGAspect<MyTraceAspect>();
    a->addGAspect<MyTemplateAspect<int, double>>(20, 7.0);

// 继承GAspect之后，实现逻辑，beginInit、finishInit、beginRun、finishRun、beginDestroy、finishDestroy
```

- 可以通过切面参数，来传递一些信息

```C++
// 构造图的时候，addGAspect传入参数
    a->addGAspect<MyConnAspect, MyConnParam>(&paramA);

// Aspect中，getAParam<MyConnParam>()获取参数
    CStatus beginInit() override {
        auto* param = this->getAParam<MyConnParam>();    // 注意，这里是AParam，表示的是切面自己的参数，不是GParam
        if (param) {
            // 如果传入类型不匹配，则返回param值为空
            mockConnect(param->ip_, param->port_);
        }

        return CStatus();
    }
```

### Singleton 节点（T11）

- 单例

### CFunction 节点（T12）

- 用来把一个 lambda 构造成节点。 通过捕获列表，可以不通过 Param 功能传入传出一些信息，相当于开了个口子？
- 看作者的介绍，也是不推荐这种用法，而是为了老代码的快速迁移

> http://www.chunel.cn/archives/cgraph-function-introduce

```C++
GFunctionPtr c_function, d_function = nullptr;    // 申明两个 GFunction 类型的变量

// 注册
status += pipeline->registerGElement<GFunction>(&c_function, {b}, "functionC", 1);    // 注册GFunction类型的节点c_function

// 设置回调，可以设置多个
int num = 10;
d_function->setFunction(CFunctionType::INIT, [d_function] {
    CGRAPH_ECHO("[%s] do init function ...", d_function->getName().c_str());
    return CStatus();
})->setFunction(CFunctionType::RUN, [d_function, num] {
    auto param = d_function->getGParamWithNoEmpty<MyParam>("param1");
    param->iCount += num;
    CGRAPH_ECHO("[%s] do run function, iCount = [%d], iValue = [%d] ...",
                d_function->getName().c_str(), param->iCount, ++param->iValue);
    return CStatus();
});
```

### 定时任务：Daemon（T13）

```C++
    pipeline->addGDaemon<MyMonitorDaemon>(4000)   // 间隔4s执行
            ->addGDaemon<MyParamDaemon, MyConnParam>(3500, &connParam)    // 间隔3500ms执行，并且传入参数
            ->addGDaemon<MyTemplateDaemon<int>>(2750, 300);    // 添加模板daemon信息
```

### Hold 机制：（T14）

- 通过一个条件，判断节点是否继续重复执行
    - 为什么不直接在 run 里作为循环条件？ 不过相当于加了一个调度点

```C++
    CBool isHold() override {
        /**
         * 针对当前场景，添加 hold逻辑
         * 当 hold逻辑被满足的时候，会重复执行当前节点，直到返回false为止
         * 也可以用isHold机制，实现算子内部自己的状态机机制
         */
        auto param = CGRAPH_GET_GPARAM(MyParam, HOLD_PARAM_NAME)
        if (nullptr == param) {
            return false;    // 如果未读取到参数，则直接结束，不继续执行了
        }

        CGraph::CGRAPH_ECHO("enter hold path, iValue = [%d]", param->iValue);
        return param->iValue < 5;    // 当 iValue 值小于5的时候，此节点会持续执行
    }
```

### 参数：EParam（T15）

- 更像 side_packet，不在 pipeline 中共享，节点独有。

```C++
// 给节点添加参数
v1->addEParam(VERSION_PARAM_KEY, &vp1);

// 节点内部获取参数
auto* version = CGRAPH_GET_EPARAM(MyVersionParam, VERSION_PARAM_KEY)
if (nullptr != version) {
    CGraph::CGRAPH_ECHO("[%s] version is [%d-%d]",
                        this->getName().c_str(), version->priority_, version->secondary_);
}
```

### 消息传递：Message（T16、T17）

- 前面的 param，只能在单个 pipeline 中共享数据。
- Message，可以在多个 pipeline 之间传递消息。
- send/recv：一发一收，channel。

```C++
// 发送
std::unique_ptr<MyMessageParam> mp(new MyMessageParam());
CStatus status = CGRAPH_SEND_MPARAM(MyMessageParam, "send-recv", mp, CGraph::GMessagePushStrategy::WAIT)

// 接收
std::unique_ptr<MyMessageParam> mp = nullptr;    // 接收一个消息
CStatus status = CGRAPH_RECV_MPARAM(MyMessageParam, "send-recv", mp);
```

- pub/sub：一发多收

```C++
// 发送
MyMessageParam mp;    // 创建一个消息，并且发送出去
CStatus status = CGRAPH_PUB_MPARAM(MyMessageParam, "pub-sub", mp, CGraph::GMessagePushStrategy::WAIT);

// 接收
std::unique_ptr<MyMessageParam> mp = nullptr;    // 通过智能指针类型，接收一个消息。相比value接收(Recv or Sub)，性能会好一些
CStatus status = CGRAPH_SUB_MPARAM(MyMessageParam, conn_id_, mp)
```

### 事件：Event（T18）

- 方便在一些特定的条件下，触发一段逻辑的执行。可以同步/异步

```C++
// 构建pipeline时，可以添加event触发后的执行逻辑
pipeline->addGEvent<MyPrintEvent>("my-print-event");

// 在graph的执行过程中，node内部可以通过notify来触发一段逻辑的执行
notify("my-print-event", GEventType::SYNC);
```

### 执行控制（T19、T20）

可以对 pipeline 的执行进行一定的控制

- 取消：（T19）

```C++
pipeline->cancel()
```

- yield/resume（T20）

```C++
status += pipeline->yield();    // 暂停执行，保留当前pipeline内部所有参数信息和状态信息
status += pipeline->resume();     // 暂停一段时间后，恢复执行
```

### 条件选择：MultiCondition（T21）

- 可以把几个 node 组合到一起
- node 中，override `isMatch` 方法，来决定是否需要执行

```C++
b_multi_condition = pipeline->createGGroup<GMultiCondition<GMultiConditionType::SERIAL>>({
    pipeline->createGNode<MyNode1>(GNodeInfo("nodeB1")),    // 本节点【不会】执行，因为默认不执行
    pipeline->createGNode<MyMatchNode>(GNodeInfo("nodeB2"))    // 本节点【会】执行，因为 isMatch() 返回为 true
});
```

### 超时：Timeout（T22）

### Some：任意一个完成，即可触发后续任务（T23）

### Fence：用来等待异步任务结束（T24）

### Coordinator：运行过程中，动态调整线程数（T25）

### Mutable：运行过程中，动态调整依赖关系（T26）

`reshape`

```C++
    CStatus reshape(CGraph::GElementPtrArr& elements) override {
        auto param = CGRAPH_GET_GPARAM_WITH_NO_EMPTY(MyParam, "param1")
        int count = param->iCount % 4;
        if (0 == count) {
            CGraph::CGRAPH_ECHO("---- run as a->[b,c]");
            (*elements[0])-->elements[1] & elements[2];
        }
        // ...
        return CStatus();
    }
```

### trim()：删除不必要的依赖关系（T27）

```C++
pipeline->registerGElement<MyNode1>(&a, {}, "nodeA");
pipeline->registerGElement<MyNode2>(&b, {a}, "nodeB");
pipeline->registerGElement<MyNode1>(&c, {a}, "nodeC");

/**
 * 可以看出，d节点 对a 的依赖，是可有可无的
 * 建议通过 trim() 接口删除冗余依赖
 * 参考文档：http://www.chunel.cn/archives/cgraph-remove-redundancy-link
 */
pipeline->registerGElement<MyNode2>(&d, {a, b, c}, "nodeD");

auto trimSize = pipeline->trim();
```

### 线程池（TU01）

- 提交任务
    - commit 非阻塞接口

```C++
auto r1 = tp->commit([i, j] { return add(i, j); });
```

    - submit：阻塞接口

    ```C++
    tp->submit([i] { std::cout << i << " "; });    // 可以看到，submit版本是有序执行的。如果需要想要无序执行，可以通过创建taskGroup的方式进行，或者使用commit方法
    ```

- taskGroup：可以把一组任务，放到一起提交，来统一设置超时时间

    ```C++ unwrap
    UTaskGroup taskGroup;

    /** 添加一个耗时为1000ms的任务 */
    taskGroup.addTask([i, j] {
        int result = i + j;
        CGRAPH_SLEEP_MILLISECOND(1000)
        CGRAPH_ECHO("sleep for 1 second, [%d] + [%d] = [%d], run success.", i, j, result);
    });

    CStatus status = tp->submit(taskGroup, 2500);
    ```