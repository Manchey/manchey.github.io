---
date: '2025-01-15 00:00:00'
title: mutex&cv性能测试
type: post
---

# mutex&cv性能测试

## 参考

- condition_variable 性能测试：
    - 参考：[https://www.modernescpp.com/index.php/performancecomparison-of-condition-variables-and-atomics-in-c-20/](https://www.modernescpp.com/index.php/performancecomparison-of-condition-variables-and-atomics-in-c-20/)
    - 两个线程，ping-pong 互相通知，测试单位时间内的 ping-pong 次数。
    - 测试结果：和 std::condition_variable 性能基本一致
- mutex 性能测试：
    - 参考：[https://chromium.googlesource.com/external/github.com/abseil/abseil-cpp/+/HEAD/absl/synchronization/mutex_benchmark.cc](https://chromium.googlesource.com/external/github.com/abseil/abseil-cpp/+/HEAD/absl/synchronization/mutex_benchmark.cc)
    - 测试场景：
        1. N 个线程，分别 lock、unlock
        2. N 个线程，分别先做一些操作、然后 lock、做一些操作、再 unlock
    - 测试结果：使能优先级继承后，多线程竞争情况下，lock/unlock 性能降低一个数量级左右
    - 备注：也测试了在现有实现下，仅注释掉使能优先级继承的代码，性能恢复到和 std::mutex 一个量级，说明性能下降非代码实现原因，而是优先级继承机制导致。

## 代码

```cpp
#include <condition_variable>
#include <mutex>
#include <thread>

#include <benchmark/benchmark.h>

#include "base/synchronization/condition_variable.h"

using namespace deeproute::base;

template <typename ConditionVariableType>
static void BM_PingPong(benchmark::State& state) {
  ConditionVariableType cv1, cv2;
  std::mutex mutex;
  bool data_ready = false;
  bool should_exit = false;
  size_t counter = 0;
  const size_t iterations_per_test = 10000;

  std::thread pong([&]() {
    while (!should_exit) {
      std::unique_lock<std::mutex> lock(mutex);
      cv2.wait(lock, [&]() { return data_ready || should_exit; });
      if (should_exit) break;
      data_ready = false;
      cv1.notify_one();
    }
  });

  for (auto _ : state) {
    counter = 0;
    while (counter < iterations_per_test) {
      std::unique_lock<std::mutex> lock(mutex);
      cv1.wait(lock, [&]() { return !data_ready; });
      data_ready = true;
      counter++;
      cv2.notify_one();
    }
  }

  {
    std::lock_guard<std::mutex> lock(mutex);
    should_exit = true;
    data_ready = true;
  }
  cv2.notify_one();
  pong.join();

  state.SetItemsProcessed(state.iterations() * iterations_per_test);
}

BENCHMARK_TEMPLATE(BM_PingPong, std::condition_variable);
BENCHMARK_TEMPLATE(BM_PingPong, ConditionVariable);

BENCHMARK_MAIN();
```