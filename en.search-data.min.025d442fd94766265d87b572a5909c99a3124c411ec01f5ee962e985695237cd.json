[{"id":0,"href":"/diary/","title":"Diary","section":"Home","content":" 2025-01-30 测试一下 "},{"id":1,"href":"/diary/2025-01-30/","title":"测试一下","section":"Diary","content":"测试一下\n"},{"id":2,"href":"/posts/2025/01/mutexcv%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","title":"mutex\u0026cv性能测试","section":"Blog","content":" mutex\u0026amp;cv性能测试 # 参考 # condition_variable 性能测试： 参考：https://www.modernescpp.com/index.php/performancecomparison-of-condition-variables-and-atomics-in-c-20/ 两个线程，ping-pong 互相通知，测试单位时间内的 ping-pong 次数。 测试结果：和 std::condition_variable 性能基本一致 mutex 性能测试： 参考：https://chromium.googlesource.com/external/github.com/abseil/abseil-cpp/+/HEAD/absl/synchronization/mutex_benchmark.cc 测试场景： N 个线程，分别 lock、unlock N 个线程，分别先做一些操作、然后 lock、做一些操作、再 unlock 测试结果：使能优先级继承后，多线程竞争情况下，lock/unlock 性能降低一个数量级左右 备注：也测试了在现有实现下，仅注释掉使能优先级继承的代码，性能恢复到和 std::mutex 一个量级，说明性能下降非代码实现原因，而是优先级继承机制导致。 代码 # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;benchmark/benchmark.h\u0026gt; #include \u0026#34;base/synchronization/condition_variable.h\u0026#34; using namespace deeproute::base; template \u0026lt;typename ConditionVariableType\u0026gt; static void BM_PingPong(benchmark::State\u0026amp; state) { ConditionVariableType cv1, cv2; std::mutex mutex; bool data_ready = false; bool should_exit = false; size_t counter = 0; const size_t iterations_per_test = 10000; std::thread pong([\u0026amp;]() { while (!should_exit) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex); cv2.wait(lock, [\u0026amp;]() { return data_ready || should_exit; }); if (should_exit) break; data_ready = false; cv1.notify_one(); } }); for (auto _ : state) { counter = 0; while (counter \u0026lt; iterations_per_test) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mutex); cv1.wait(lock, [\u0026amp;]() { return !data_ready; }); data_ready = true; counter++; cv2.notify_one(); } } { std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mutex); should_exit = true; data_ready = true; } cv2.notify_one(); pong.join(); state.SetItemsProcessed(state.iterations() * iterations_per_test); } BENCHMARK_TEMPLATE(BM_PingPong, std::condition_variable); BENCHMARK_TEMPLATE(BM_PingPong, ConditionVariable); BENCHMARK_MAIN(); "},{"id":3,"href":"/posts/2025/01/vim%E6%A0%B9%E6%8D%AE%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E8%BE%93%E5%85%A5%E6%B3%95/","title":"vim根据模式切换输入法","section":"Blog","content":" vim根据模式切换输入法 # 参考： macOS下vim 中文输入法切换问题和两种解决方案_mac vim 输入法自动切换-CSDN博客\nvim 安装 smartim 插件\n加入一行到 ~/.vimrc 文件:\n1 Plugin \u0026#39;ybian/smartim\u0026#39; 运行：:PluginInstall\n修改 ~/.vimrc\n1 2 \u0026#34; 设置normal模式切换到的输入法 let g:smartim_default = \u0026#39;com.apple.keylayout.US\u0026#39; 因为习惯 ctrl-c 切换，上面这个只支持 esc 切换。加一下键位映射 1 2 \u0026#34; ctrl-c 映射到 esc inoremap \u0026lt;C-c\u0026gt; \u0026lt;esc\u0026gt; "},{"id":4,"href":"/posts/2024/12/ubuntu20.04%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91cyber-rt-10.0.0/","title":"ubuntu20.04源码编译cyber rt 10.0.0","section":"Blog","content":" ubuntu20.04源码编译cyber rt 10.0.0 # 安装 fastdds # apollo 给的环境是一个 docker。third_party 里 fastdds 的 bazel build 直接通过系统路径依赖的 fastdds。\n自己的环境中没有，手动安装一下，看文档是说 10.0.0 升级到了 2.x 版本。\n参考 fastdds 官网文档安装一下。\nhttps://fast-dds.docs.eprosima.com/en/latest/installation/binaries/binaries_linux.html\n二进制版本，下载解压，sudo install.sh\n装不上 python3-xmlschema 换成 pip3 install xmlschema，然后注释掉脚本里的 python3-xmlschema clone foonathan_memory_vendor 报错；手动进入到该文件夹后 build 通过 cmake 版本不匹配，要求最低 3.20，但是自带的是 3.16。升级麻烦，直接替换了。按照经验大部分人都是随便写个版本，实际根本没用到什么新功能。 编译通过\ncyber rt # 把 third_party 里的 fastdds/uuid 依赖加上。\n还缺 bvar。\n安装 bvar # install_pkg_repo.sh 脚本里安装的。\n1 2 3 4 5 6 7 8 # 添加 Apollo 的 GPG 密钥 curl -fsSL https://apollo-pkg-beta.cdn.bcebos.com/neo/beta/key/deb.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/apolloauto.gpg # 添加 Apollo 的软件源 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/apolloauto.gpg] https://apollo-pkg-beta.cdn.bcebos.com/apollo/core $(. /etc/os-release \u0026amp;\u0026amp; echo \u0026#34;$VERSION_CODENAME\u0026#34;) main\u0026#34; | sudo tee /etc/apt/sources.list.d/apolloauto.list sudo apt update sudo apt-get install bvar 装不上，有人提 issue：\nhttps://github.com/ApolloAuto/apollo/issues/15614\n这个库里有 deb：\nhttps://github.com/minhanghuang/CyberRT/tree/v10.0.0-rc1\n1 sudo dpkg -i xxx.deb 不知为何有个这个 define，报了一堆 fastdds 的错，注释掉之后编译通过\n依赖 cyber rt 的代码编译 # workspace # 1 2 3 4 5 6 7 8 local_repository( name = \u0026#34;apollo\u0026#34;, path = \u0026#34;../apollo\u0026#34;, ) # 添加 apollo 的依赖 load(\u0026#34;@apollo//tools:workspace.bzl\u0026#34;, \u0026#34;apollo_repositories\u0026#34;) apollo_repositories() 报了 -lfastrtps 找不到的问题\n在 cyber rt 的库里加了下 -L\nmonorepo 中编译 # 缺了俩环境变量：\n1 2 export UBUNTU=“2004” export PLATFORM=“X86\u0026#34; "},{"id":5,"href":"/posts/2024/12/cgraph%E8%B0%83%E7%A0%94/","title":"CGraph调研","section":"Blog","content":" CGraph调研 # repo：https://github.com/ChunelFeng/CGraph\n功能 # 建立依赖图关系：GPipeline、GNode（T00/T01） # 一条 pipeline 是从头执行到尾的，其实是 graph 的概念，没有流水线的功能 1 status += pipeline-\u0026gt;registerGElement\u0026lt;MyNode2\u0026gt;(\u0026amp;b, {a}, \u0026#34;nodeB\u0026#34;); // 将名为nodeB，依赖a执行的node信息，注册入pipeline中 子图：Cluster / Region：类似 subgraph，互相可嵌套（T02/T03/T04） # cluster：subgraph 中的多个节点串行执行 http://www.chunel.cn/archives/cgraph-run-introduce 这个解释感觉有点奇怪，D/F 未能并行执行是实现机制的问题，感觉不需要引入新的概念来解决。 region：可以是 DAG 图 1 2 3 4 5 b_cluster = pipeline-\u0026gt;createGGroup\u0026lt;GCluster\u0026gt;({ pipeline-\u0026gt;createGNode\u0026lt;MyNode1\u0026gt;(GNodeInfo(\u0026#34;nodeB1\u0026#34;, 1)), // 创建名为nodeB1的node信息，并将其放入b_cluster中 pipeline-\u0026gt;createGNode\u0026lt;MyNode1\u0026gt;(GNodeInfo(\u0026#34;nodeB2\u0026#34;, 3)), // 创建名为nodeB2且自循环3次的node信息，并将其放入b_cluster中 pipeline-\u0026gt;createGNode\u0026lt;MyNode2\u0026gt;(GNodeInfo(\u0026#34;nodeB3\u0026#34;, 1)) }); // 创建cluster信息，包含了三个node信息 1 b_region = pipeline-\u0026gt;createGGroup\u0026lt;GRegion\u0026gt;({b1, b2, b3, b4}); // 将 b1、b2、b3、b4 注册入b_region中 参数传递：param (T05) # 相当于是一个 map，同一个 pipeline 中各个节点共享的全局参数。\n1 2 3 4 5 6 7 8 // 创建 status = CGRAPH_CREATE_GPARAM(MyParam, \u0026#34;param1\u0026#34;) // 读取 auto* myParam = CGRAPH_GET_GPARAM_WITH_NO_EMPTY(MyParam, \u0026#34;param1\u0026#34;) // 写入 CGRAPH_PARAM_WRITE_CODE_BLOCK(myParam) 条件选择：Condition （T06） # 根据 choose 返回值，来决定下一步运行哪一个节点。\nchoose 函数里，可以通过 param 来获取到外界信息，做一些判断。\n1 2 3 4 5 b_condition = pipeline-\u0026gt;createGGroup\u0026lt;MyCondition\u0026gt;({ pipeline-\u0026gt;createGNode\u0026lt;MyNode1\u0026gt;(GNodeInfo(\u0026#34;conditionNodeB0\u0026#34;, 1)), pipeline-\u0026gt;createGNode\u0026lt;MyNode2\u0026gt;(GNodeInfo(\u0026#34;conditionNodeB1\u0026#34;, 1)), pipeline-\u0026gt;createGNode\u0026lt;MyNode1\u0026gt;(GNodeInfo(\u0026#34;conditionNodeB2\u0026#34;, 1)) }); // 生成 b_condition。执行的时候，根据choose()的返回值，在B0,B1,B2中选择一个执行 多条 pipeline (T07) # 手动指定线程池 1 2 3 4 5 6 7 8 9 10 11 12 // 创建线程池 UThreadPoolConfig config; config.default_thread_size_ = 4; config.max_thread_size_ = 4; config.monitor_enable_ = false; UThreadPool pool(true, config); // 开辟一个4个线程的线程池，直接 init，并且参数设置为 config // 指定pipeline使用的线程池 pipeline_1-\u0026gt;setSharedThreadPool(\u0026amp;pool); // 多个pipeline，可以共享同一个线程池 pipeline_2-\u0026gt;setSharedThreadPool(\u0026amp;pool); 异步执行 n 次： 只是包装了一下 std::async，没有其他特殊处理 1 return pipeline_1-\u0026gt;asyncProcess(5); // std::future\u0026lt;CStatus\u0026gt; 有初始化参数的 GNode (T08) # 会用传入的参数，初始化这个 node。 1 pipeline-\u0026gt;registerGElement\u0026lt;MyTemplateNode\u0026lt;int, float\u0026gt;\u0026gt;(\u0026amp;a, {}, 3, 3.5f); 切面 GAspect ：（T09/T10） # Observer，可以在几个执行点前后（init/run/destroy）插入逻辑。 1 2 3 4 a-\u0026gt;addGAspect\u0026lt;MyTraceAspect\u0026gt;(); a-\u0026gt;addGAspect\u0026lt;MyTemplateAspect\u0026lt;int, double\u0026gt;\u0026gt;(20, 7.0); // 继承GAspect之后，实现逻辑，beginInit、finishInit、beginRun、finishRun、beginDestroy、finishDestroy 可以通过切面参数，来传递一些信息 1 2 3 4 5 6 7 8 9 10 11 12 13 // 构造图的时候，addGAspect传入参数 a-\u0026gt;addGAspect\u0026lt;MyConnAspect, MyConnParam\u0026gt;(\u0026amp;paramA); // Aspect中，getAParam\u0026lt;MyConnParam\u0026gt;()获取参数 CStatus beginInit() override { auto* param = this-\u0026gt;getAParam\u0026lt;MyConnParam\u0026gt;(); // 注意，这里是AParam，表示的是切面自己的参数，不是GParam if (param) { // 如果传入类型不匹配，则返回param值为空 mockConnect(param-\u0026gt;ip_, param-\u0026gt;port_); } return CStatus(); } Singleton 节点（T11） # 单例 CFunction 节点（T12） # 用来把一个 lambda 构造成节点。 通过捕获列表，可以不通过 Param 功能传入传出一些信息，相当于开了个口子？ 看作者的介绍，也是不推荐这种用法，而是为了老代码的快速迁移 http://www.chunel.cn/archives/cgraph-function-introduce\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 GFunctionPtr c_function, d_function = nullptr; // 申明两个 GFunction 类型的变量 // 注册 status += pipeline-\u0026gt;registerGElement\u0026lt;GFunction\u0026gt;(\u0026amp;c_function, {b}, \u0026#34;functionC\u0026#34;, 1); // 注册GFunction类型的节点c_function // 设置回调，可以设置多个 int num = 10; d_function-\u0026gt;setFunction(CFunctionType::INIT, [d_function] { CGRAPH_ECHO(\u0026#34;[%s] do init function ...\u0026#34;, d_function-\u0026gt;getName().c_str()); return CStatus(); })-\u0026gt;setFunction(CFunctionType::RUN, [d_function, num] { auto param = d_function-\u0026gt;getGParamWithNoEmpty\u0026lt;MyParam\u0026gt;(\u0026#34;param1\u0026#34;); param-\u0026gt;iCount += num; CGRAPH_ECHO(\u0026#34;[%s] do run function, iCount = [%d], iValue = [%d] ...\u0026#34;, d_function-\u0026gt;getName().c_str(), param-\u0026gt;iCount, ++param-\u0026gt;iValue); return CStatus(); }); 定时任务：Daemon（T13） # 1 2 3 pipeline-\u0026gt;addGDaemon\u0026lt;MyMonitorDaemon\u0026gt;(4000) // 间隔4s执行 -\u0026gt;addGDaemon\u0026lt;MyParamDaemon, MyConnParam\u0026gt;(3500, \u0026amp;connParam) // 间隔3500ms执行，并且传入参数 -\u0026gt;addGDaemon\u0026lt;MyTemplateDaemon\u0026lt;int\u0026gt;\u0026gt;(2750, 300); // 添加模板daemon信息 Hold 机制：（T14） # 通过一个条件，判断节点是否继续重复执行 为什么不直接在 run 里作为循环条件？ 不过相当于加了一个调度点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 CBool isHold() override { /** * 针对当前场景，添加 hold逻辑 * 当 hold逻辑被满足的时候，会重复执行当前节点，直到返回false为止 * 也可以用isHold机制，实现算子内部自己的状态机机制 */ auto param = CGRAPH_GET_GPARAM(MyParam, HOLD_PARAM_NAME) if (nullptr == param) { return false; // 如果未读取到参数，则直接结束，不继续执行了 } CGraph::CGRAPH_ECHO(\u0026#34;enter hold path, iValue = [%d]\u0026#34;, param-\u0026gt;iValue); return param-\u0026gt;iValue \u0026lt; 5; // 当 iValue 值小于5的时候，此节点会持续执行 } 参数：EParam（T15） # 更像 side_packet，不在 pipeline 中共享，节点独有。 1 2 3 4 5 6 7 8 9 // 给节点添加参数 v1-\u0026gt;addEParam(VERSION_PARAM_KEY, \u0026amp;vp1); // 节点内部获取参数 auto* version = CGRAPH_GET_EPARAM(MyVersionParam, VERSION_PARAM_KEY) if (nullptr != version) { CGraph::CGRAPH_ECHO(\u0026#34;[%s] version is [%d-%d]\u0026#34;, this-\u0026gt;getName().c_str(), version-\u0026gt;priority_, version-\u0026gt;secondary_); } 消息传递：Message（T16、T17） # 前面的 param，只能在单个 pipeline 中共享数据。 Message，可以在多个 pipeline 之间传递消息。 send/recv：一发一收，channel。 1 2 3 4 5 6 7 // 发送 std::unique_ptr\u0026lt;MyMessageParam\u0026gt; mp(new MyMessageParam()); CStatus status = CGRAPH_SEND_MPARAM(MyMessageParam, \u0026#34;send-recv\u0026#34;, mp, CGraph::GMessagePushStrategy::WAIT) // 接收 std::unique_ptr\u0026lt;MyMessageParam\u0026gt; mp = nullptr; // 接收一个消息 CStatus status = CGRAPH_RECV_MPARAM(MyMessageParam, \u0026#34;send-recv\u0026#34;, mp); pub/sub：一发多收 1 2 3 4 5 6 7 // 发送 MyMessageParam mp; // 创建一个消息，并且发送出去 CStatus status = CGRAPH_PUB_MPARAM(MyMessageParam, \u0026#34;pub-sub\u0026#34;, mp, CGraph::GMessagePushStrategy::WAIT); // 接收 std::unique_ptr\u0026lt;MyMessageParam\u0026gt; mp = nullptr; // 通过智能指针类型，接收一个消息。相比value接收(Recv or Sub)，性能会好一些 CStatus status = CGRAPH_SUB_MPARAM(MyMessageParam, conn_id_, mp) 事件：Event（T18） # 方便在一些特定的条件下，触发一段逻辑的执行。可以同步/异步 1 2 3 4 5 // 构建pipeline时，可以添加event触发后的执行逻辑 pipeline-\u0026gt;addGEvent\u0026lt;MyPrintEvent\u0026gt;(\u0026#34;my-print-event\u0026#34;); // 在graph的执行过程中，node内部可以通过notify来触发一段逻辑的执行 notify(\u0026#34;my-print-event\u0026#34;, GEventType::SYNC); 执行控制（T19、T20） # 可以对 pipeline 的执行进行一定的控制\n取消：（T19） 1 pipeline-\u0026gt;cancel() yield/resume（T20） 1 2 status += pipeline-\u0026gt;yield(); // 暂停执行，保留当前pipeline内部所有参数信息和状态信息 status += pipeline-\u0026gt;resume(); // 暂停一段时间后，恢复执行 条件选择：MultiCondition（T21） # 可以把几个 node 组合到一起 node 中，override isMatch 方法，来决定是否需要执行 1 2 3 4 b_multi_condition = pipeline-\u0026gt;createGGroup\u0026lt;GMultiCondition\u0026lt;GMultiConditionType::SERIAL\u0026gt;\u0026gt;({ pipeline-\u0026gt;createGNode\u0026lt;MyNode1\u0026gt;(GNodeInfo(\u0026#34;nodeB1\u0026#34;)), // 本节点【不会】执行，因为默认不执行 pipeline-\u0026gt;createGNode\u0026lt;MyMatchNode\u0026gt;(GNodeInfo(\u0026#34;nodeB2\u0026#34;)) // 本节点【会】执行，因为 isMatch() 返回为 true }); 超时：Timeout（T22） # Some：任意一个完成，即可触发后续任务（T23） # Fence：用来等待异步任务结束（T24） # Coordinator：运行过程中，动态调整线程数（T25） # Mutable：运行过程中，动态调整依赖关系（T26） # reshape\n1 2 3 4 5 6 7 8 9 10 CStatus reshape(CGraph::GElementPtrArr\u0026amp; elements) override { auto param = CGRAPH_GET_GPARAM_WITH_NO_EMPTY(MyParam, \u0026#34;param1\u0026#34;) int count = param-\u0026gt;iCount % 4; if (0 == count) { CGraph::CGRAPH_ECHO(\u0026#34;---- run as a-\u0026gt;[b,c]\u0026#34;); (*elements[0])--\u0026gt;elements[1] \u0026amp; elements[2]; } // ... return CStatus(); } trim()：删除不必要的依赖关系（T27） # 1 2 3 4 5 6 7 8 9 10 11 12 pipeline-\u0026gt;registerGElement\u0026lt;MyNode1\u0026gt;(\u0026amp;a, {}, \u0026#34;nodeA\u0026#34;); pipeline-\u0026gt;registerGElement\u0026lt;MyNode2\u0026gt;(\u0026amp;b, {a}, \u0026#34;nodeB\u0026#34;); pipeline-\u0026gt;registerGElement\u0026lt;MyNode1\u0026gt;(\u0026amp;c, {a}, \u0026#34;nodeC\u0026#34;); /** * 可以看出，d节点 对a 的依赖，是可有可无的 * 建议通过 trim() 接口删除冗余依赖 * 参考文档：http://www.chunel.cn/archives/cgraph-remove-redundancy-link */ pipeline-\u0026gt;registerGElement\u0026lt;MyNode2\u0026gt;(\u0026amp;d, {a, b, c}, \u0026#34;nodeD\u0026#34;); auto trimSize = pipeline-\u0026gt;trim(); 线程池（TU01） # 提交任务 commit 非阻塞接口 1 auto r1 = tp-\u0026gt;commit([i, j] { return add(i, j); }); - submit：阻塞接口 ```C++ tp-\u0026gt;submit([i] { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;; }); // 可以看到，submit版本是有序执行的。如果需要想要无序执行，可以通过创建taskGroup的方式进行，或者使用commit方法 ``` taskGroup：可以把一组任务，放到一起提交，来统一设置超时时间\n1 2 3 4 5 6 7 8 9 10 UTaskGroup taskGroup; /** 添加一个耗时为1000ms的任务 */ taskGroup.addTask([i, j] { int result = i + j; CGRAPH_SLEEP_MILLISECOND(1000) CGRAPH_ECHO(\u0026#34;sleep for 1 second, [%d] + [%d] = [%d], run success.\u0026#34;, i, j, result); }); CStatus status = tp-\u0026gt;submit(taskGroup, 2500); "},{"id":6,"href":"/posts/2024/12/mac%E4%B8%ADvscode%E6%89%93%E5%BC%80devdocker%E6%8F%90%E7%A4%BAremote-extension-host-terminated-unexpectedly/","title":"mac中vscode打开devdocker提示\"remote-extension-host-terminated-unexpectedly\"","section":"Blog","content":" 参考 # https://github.com/microsoft/vscode-remote-release/issues/8967#issuecomment-1873199481\nswitched from VirtioFS to gRPC FUSE and disabled \u0026lsquo;Use Virtualization Framework\u0026rsquo; in my Docker Desktop settings\n"},{"id":7,"href":"/about/","title":"About","section":"Home","content":"Manchey Lee\ne-mail: ljq0831@qq.com github: https://github.com/manchey "},{"id":8,"href":"/post/","title":"Blog","section":"Home","content":""}]