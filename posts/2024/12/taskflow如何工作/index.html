<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  运行机制
  #


  Executor
  #

构造函数，可以看出来它的成员：

N 个线程
N 个 Worker，每个 Worker 一个线程
Notifier，负责线程之间通知的
Latch，负责主线程和 Worker 线程的初始化的同步的
FreeList，一个有锁队列，主线程提交任务时就会往这里填充，或者 Worker 线程提交任务时，发现 Worker 自己的队列满了就往 FreeList 提交


Executor 的构造函数中初始化了 thread local 的 Worker，创建 N 个线程，每个线程是一个 while(1)，等待 task、执行 task。
Executor::Executor(size_t N) -》_spawn(N)：


Executor 也是有两级的链表：

第一级是 Executor 会有以及，它是无界、lock-free 队列（Push 有锁，但是 Steal 是无锁的，也就是说适合单生产者 - 多消费者场景）：Freelist&lt;Node*&gt; _freelist;
第二级是每个 Worker 都有一个有界的、lock-free 队列：BoundedTaskQueue&lt;Node*&gt; _wsq;

Executor 的 run 函数，会将没有 depends 的 node 直接放入到 freelist 中，这样整个 graph 就可以运转起来了：">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/2024/12/taskflow%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/">
  <meta property="og:site_name" content="Manchey Blog">
  <meta property="og:title" content="Taskflow如何工作">
  <meta property="og:description" content="运行机制 # Executor # 构造函数，可以看出来它的成员：
N 个线程 N 个 Worker，每个 Worker 一个线程 Notifier，负责线程之间通知的 Latch，负责主线程和 Worker 线程的初始化的同步的 FreeList，一个有锁队列，主线程提交任务时就会往这里填充，或者 Worker 线程提交任务时，发现 Worker 自己的队列满了就往 FreeList 提交 Executor 的构造函数中初始化了 thread local 的 Worker，创建 N 个线程，每个线程是一个 while(1)，等待 task、执行 task。
Executor::Executor(size_t N) -》_spawn(N)：
Executor 也是有两级的链表：
第一级是 Executor 会有以及，它是无界、lock-free 队列（Push 有锁，但是 Steal 是无锁的，也就是说适合单生产者 - 多消费者场景）：Freelist&lt;Node*&gt; _freelist; 第二级是每个 Worker 都有一个有界的、lock-free 队列：BoundedTaskQueue&lt;Node*&gt; _wsq; Executor 的 run 函数，会将没有 depends 的 node 直接放入到 freelist 中，这样整个 graph 就可以运转起来了：">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-12-12T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-12-12T00:00:00+00:00">
    <meta property="article:tag" content="Tech/Cpp/Scheduler/Taskflow">
    <meta property="article:tag" content="非原创">
<title>Taskflow如何工作 | Manchey Blog</title>
<link rel="icon" href="http://localhost:1313/logo.png" >
<link rel="manifest" href="http://localhost:1313/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/2024/12/taskflow%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/">
<link rel="stylesheet" href="http://localhost:1313/book.min.2d11051f9bbf9eb3c1e80b2b7a60b21379d1b88bdcc5a0c2b268ec9357d72f50.css" integrity="sha256-LREFH5u/nrPB6AsremCyE3nRuIvcxaDCsmjsk1fXL1A=" crossorigin="anonymous">
  <script defer src="http://localhost:1313/fuse.min.js"></script>
  <script defer src="http://localhost:1313/en.search.min.41873f4a8e861b1c2598929dd6c471abbce53c920d7f4046a555c40b88d9374c.js" integrity="sha256-QYc/So6GGxwlmJKd1sRxq7zlPJINf0BGpVXEC4jZN0w=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="http://localhost:1313/"><img src="http://localhost:1313/logo.png" alt="Logo" class="book-icon" /><span>Manchey Blog</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>























  
<ul>
  
  <li>
    <a href="http://localhost:1313/"  >
        Home
      </a>
  </li>
  
  <li>
    <a href="http://localhost:1313/post/"  >
        Blog
      </a>
  </li>
  
  <li>
    <a href="http://localhost:1313/about/"  >
        About
      </a>
  </li>
  
  <li>
    <a href="https://github.com/Manchey/manchey.github.io"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="http://localhost:1313/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Taskflow如何工作</h3>

  <label for="toc-control">
    
    <img src="http://localhost:1313/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#运行机制">运行机制</a>
      <ul>
        <li><a href="#executor">Executor</a></li>
        <li><a href="#task">Task</a></li>
        <li><a href="#node">Node</a></li>
        <li><a href="#graph">Graph</a></li>
        <li><a href="#runtime">Runtime</a></li>
        <li><a href="#topology">Topology</a></li>
        <li><a href="#taskflow">Taskflow</a></li>
        <li><a href="#pipeline">Pipeline</a></li>
      </ul>
    </li>
    <li><a href="#taskflow-的问题">Taskflow 的问题</a>
      <ul>
        <li><a href="#executor-和-graph-耦合比较深">Executor 和 Graph 耦合比较深</a></li>
        <li><a href="#缺少数据流抽象">缺少数据流抽象</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h2 id="运行机制">
  运行机制
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6">#</a>
</h2>
<h3 id="executor">
  Executor
  <a class="anchor" href="#executor">#</a>
</h3>
<p>构造函数，可以看出来它的成员：</p>
<ol>
<li>N 个线程</li>
<li>N 个 Worker，每个 Worker 一个线程</li>
<li>Notifier，负责线程之间通知的</li>
<li>Latch，负责主线程和 Worker 线程的初始化的同步的</li>
<li>FreeList，一个有锁队列，主线程提交任务时就会往这里填充，或者 Worker 线程提交任务时，发现 Worker 自己的队列满了就往 FreeList 提交</li>
</ol>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@e9a1f7b6-7efa-4839-8e6d-f4cf815545dc.png" alt="" /></p>
<p>Executor 的构造函数中初始化了 thread local 的 Worker，创建 N 个线程，每个线程是一个 while(1)，等待 task、执行 task。</p>
<p>Executor::Executor(size_t N) -》_spawn(N)：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@e73c0e09-2f76-420e-8348-680d212f3345.png" alt="" /></p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@93169a2e-e0cf-4880-94ea-7669e182048d.png" alt="" /></p>
<p>Executor 也是有两级的链表：</p>
<ol>
<li>第一级是 Executor 会有以及，它是无界、lock-free 队列（Push 有锁，但是 Steal 是无锁的，也就是说适合单生产者 - 多消费者场景）：Freelist&lt;Node*&gt; _freelist;</li>
<li>第二级是每个 Worker 都有一个有界的、lock-free 队列：BoundedTaskQueue&lt;Node*&gt; _wsq;</li>
</ol>
<p>Executor 的 run 函数，会将没有 depends 的 node 直接放入到 freelist 中，这样整个 graph 就可以运转起来了：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@fcb05a87-2746-459b-9be1-5af539e11604.png" alt="" /></p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@1d55ff1f-325b-4612-a23a-971a0c568eb7.png" alt="" /></p>
<p>Worker 线程会从 freelist steal 到 Node，然后调用 _invoke 来执行 Node，invoke task 的时候会判断它的 _successors 的情况，如果 join_counter 为了 0，则 graph 的下游 Node 可以被调度了（放入队列，或者放到 worker._cache 中直接 goto 执行）：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@fd5144b5-41ba-477c-af57-67cf565b07ee.png" alt="" /></p>
<h3 id="task">
  Task
  <a class="anchor" href="#task">#</a>
</h3>
<p>基本就是对 Node 的封装。</p>
<h3 id="node">
  Node
  <a class="anchor" href="#node">#</a>
</h3>
<p>node 是 Graph 中的一个节点，成员变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> _state {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>string _name;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> _data {<span style="color:#66d9ef">nullptr</span>};
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  Topology<span style="color:#f92672">*</span> _topology {<span style="color:#66d9ef">nullptr</span>};
</span></span><span style="display:flex;"><span>  Node<span style="color:#f92672">*</span> _parent {<span style="color:#66d9ef">nullptr</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 这两个描述的就是上下游的链接关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  SmallVector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span> _successors;
</span></span><span style="display:flex;"><span>  SmallVector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span> _dependents;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 描述当前Node的是否Ready的入度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> _join_counter {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>exception_ptr _exception_ptr {<span style="color:#66d9ef">nullptr</span>};
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 可执行函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  handle_t _handle;
</span></span></code></pre></div><p>Node 有多种类型：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@64e8a3a1-0d6d-402c-9eae-6f7e3a4c4de8.png" alt="" /></p>
<h3 id="graph">
  Graph
  <a class="anchor" href="#graph">#</a>
</h3>
<p>成员变量：很简单，只有一个 vector</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span> _nodes;    
</span></span></code></pre></div><h3 id="runtime">
  Runtime
  <a class="anchor" href="#runtime">#</a>
</h3>
<p>Executor 在执行一个 Node 时，需要根据其类型来判断以何种方式调用。具体应用参考这个：https://taskflow.github.io/taskflow/RuntimeTasking.html，一种动态调度 Node 的方式，脱离 DAG 的一种执行 Node 的方式，看起来有点太灵活了，不知道用于什么场景。</p>
<p>解释：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@361ba27a-6401-4567-b75f-131517fc9bdd.png" alt="" /></p>
<p>成员变量：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@75888acd-4a48-49a5-a97c-33781f525010.png" alt="" /></p>
<p>Executor 的某种场景：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@30ccf1ed-84b6-441c-b9a4-a58cac2aca21.png" alt="" /></p>
<h3 id="topology">
  Topology
  <a class="anchor" href="#topology">#</a>
</h3>
<p>成员变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    Taskflow<span style="color:#f92672">&amp;</span> _taskflow;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>promise<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span> _promise;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    SmallVector<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">*&gt;</span> _sources;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>()<span style="color:#f92672">&gt;</span> _pred;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> _call;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span>size_t<span style="color:#f92672">&gt;</span> _join_counter {<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> _state {CLEAN};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>exception_ptr _exception_ptr {<span style="color:#66d9ef">nullptr</span>};
</span></span></code></pre></div><p>Executor 的 run_until 函数会创建一个 Topology，每次运行都创建一个 Topology，所以 Taskflow 中是一个 Topology 的 vector，Taskflow 可以多次提交给 Executor，每次都会创建一个 Topology，可能是记录本次运行的情况。</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@940ebcee-dcc0-4d28-89cb-4d83076ea10f.png" alt="" /></p>
<h3 id="taskflow">
  Taskflow
  <a class="anchor" href="#taskflow">#</a>
</h3>
<p>成员变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">mutable</span> std<span style="color:#f92672">::</span>mutex _mutex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string _name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Graph _graph;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Topology<span style="color:#f92672">&gt;&gt;</span> _topologies;
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>list<span style="color:#f92672">&lt;</span>Taskflow<span style="color:#f92672">&gt;::</span>iterator<span style="color:#f92672">&gt;</span> _satellite;
</span></span></code></pre></div><p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@dcec80f4-cc82-45f2-b24f-7444c60dea4e.png" alt="" /></p>
<h3 id="pipeline">
  Pipeline
  <a class="anchor" href="#pipeline">#</a>
</h3>
<p>Pipeline 实际是创建了一个 Module Task：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@8462af9f-2f1f-4e4f-b2ff-d2a229dcab58.png" alt="" /></p>
<p>这里实际是重新 setup 了一个 graph，并开始调度：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@f9fb0498-1934-43c2-bc3f-b1327f81517c.png" alt="" /></p>
<p>这个 until 很有意思，为了不空等，它实际是一个 while 循环，里面还是在执行 Node，只不过会有终止条件，就是 until 的第二个参数：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@c2967253-3b51-4164-8084-11b073cf4bc0.png" alt="" /></p>
<p>针对 Pipeline 实际上又创建了一个 Pipeflow，而且针对是串行还是并行，两次 line 之间是有依赖关系的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>    <span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>v    v    v
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">和下面的图是不一样的：</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>v    
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">这个图允许</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">和</span><span style="color:#ae81ff">3</span> pipe并行执行<span style="color:#960050;background-color:#1e0010">，但是</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">要求是必须串行执行</span>
</span></span></code></pre></div><p>同时对于 Pipe 的执行，也是在一个 Module Task 中执行的，它内部用 goto 实现了一个循环，所以 Pipe 和 Task（Node）都没有关联关系：</p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@ed69f1aa-9fa7-487b-b74a-0ab874073d06.png" alt="" /></p>
<p><img src="assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@324470a7-88f0-481e-8e99-4e92121d486d.png" alt="" /></p>
<p>同时看起来它也不支持复杂的 pipeline，每条 line 只有一个分支，不能将一个复杂的 DAG 作为一条 line。</p>
<h2 id="taskflow-的问题">
  Taskflow 的问题
  <a class="anchor" href="#taskflow-%e7%9a%84%e9%97%ae%e9%a2%98">#</a>
</h2>
<p>不能适用于我们场景的一些问题。</p>
<h3 id="executor-和-graph-耦合比较深">
  Executor 和 Graph 耦合比较深
  <a class="anchor" href="#executor-%e5%92%8c-graph-%e8%80%a6%e5%90%88%e6%af%94%e8%be%83%e6%b7%b1">#</a>
</h3>
<p>Executor 中直接使用了 Node，但是 Node 其实是 Graph 的组成部分，相当于 Graph 和 Executor 耦合的比较深，感觉需要一个中间的概念将它俩联系起来比较好，或者至少和 Mediapipe 一样，通过回调的方式分离 Scheduler 和 CalculatorNode 的一些逻辑（当然还是有一些耦合的），起码 Mediapipe 的 Executor 和 Calculator 是完全分离的，没有依赖关系，所以可以简单的替换掉 Executor。</p>
<p>所以 Taskflow 的 Executor 可以拆成两部分：Scheduler 和 Executor，Scheduler 负责和 Graph 打交道，Executor 可以更干净一些。</p>
<h3 id="缺少数据流抽象">
  缺少数据流抽象
  <a class="anchor" href="#%e7%bc%ba%e5%b0%91%e6%95%b0%e6%8d%ae%e6%b5%81%e6%8a%bd%e8%b1%a1">#</a>
</h3>
<p>缺少数据层抽象，虽然有 DataPipeline，但是它的流水线只能是简单的一条分支，不能是一个复杂的 DAG 图。</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#运行机制">运行机制</a>
      <ul>
        <li><a href="#executor">Executor</a></li>
        <li><a href="#task">Task</a></li>
        <li><a href="#node">Node</a></li>
        <li><a href="#graph">Graph</a></li>
        <li><a href="#runtime">Runtime</a></li>
        <li><a href="#topology">Topology</a></li>
        <li><a href="#taskflow">Taskflow</a></li>
        <li><a href="#pipeline">Pipeline</a></li>
      </ul>
    </li>
    <li><a href="#taskflow-的问题">Taskflow 的问题</a>
      <ul>
        <li><a href="#executor-和-graph-耦合比较深">Executor 和 Graph 耦合比较深</a></li>
        <li><a href="#缺少数据流抽象">缺少数据流抽象</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












