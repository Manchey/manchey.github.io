<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Mediapipe 的版本
  #

0.8.0

  Mediapipe 的基本概念
  #

参考：2024-06-17-Mediapipe调研

  Mediapipe 有几个线程？
  #

编译了 example 的 hello world，发现只有两类线程：

主线程，main 函数的线程，这个不用说了
Executor 线程，Mediapipe 默认只有一个 Executtor：ThreadPoolExecutor

#include &#34;mediapipe/framework/calculator_graph.h&#34;
#include &#34;mediapipe/framework/port/logging.h&#34;
#include &#34;mediapipe/framework/port/parse_text_proto.h&#34;
#include &#34;mediapipe/framework/port/status.h&#34;

namespace mediapipe {

::mediapipe::Status PrintHelloWorld() {
  // Configures a simple graph, which concatenates 2 PassThroughCalculators.
  CalculatorGraphConfig config = ParseTextProtoOrDie&lt;CalculatorGraphConfig&gt;(R&#34;(
    input_stream: &#34;in&#34;
    output_stream: &#34;out&#34;
    node {
      calculator: &#34;PassThroughCalculator&#34;
      input_stream: &#34;in&#34;
      output_stream: &#34;out1&#34;
    }
    node {
      calculator: &#34;PassThroughCalculator&#34;
      input_stream: &#34;out1&#34;
      output_stream: &#34;out&#34;
    }
  )&#34;);

  CalculatorGraph graph;
  MP_RETURN_IF_ERROR(graph.Initialize(config));
  ASSIGN_OR_RETURN(OutputStreamPoller poller,
                   graph.AddOutputStreamPoller(&#34;out&#34;));
  MP_RETURN_IF_ERROR(graph.StartRun({}));
  // Give 10 input packets that contains the same std::string &#34;Hello World!&#34;.
  for (int i = 0; i &lt; 100; &#43;&#43;i) {
    MP_RETURN_IF_ERROR(graph.AddPacketToInputStream(
        &#34;in&#34;, MakePacket&lt;std::string&gt;(&#34;Hello World!&#34;).At(Timestamp(i))));

    sleep(3);
  }
  // Close the input stream &#34;in&#34;.
  MP_RETURN_IF_ERROR(graph.CloseInputStream(&#34;in&#34;));
  mediapipe::Packet packet;
  // Get the output packets std::string.
  while (poller.Next(&amp;packet)) {
    std::cout &lt;&lt; &#34;Test: &#34; &lt;&lt; std::endl;
    LOG(ERROR) &lt;&lt; packet.Get&lt;std::string&gt;();
  }
  return graph.WaitUntilDone();
}
}  // namespace mediapipe

int main(int argc, char** argv) {
  std::cout &lt;&lt; &#34;main: &#34; &lt;&lt; std::endl;
  google::InitGoogleLogging(argv[0]);
  CHECK(mediapipe::PrintHelloWorld().ok());
  return 0;
}

  ThreadPoolExecutor 的实现
  #

它就是一个简单的 ThreadPool，提供一个 Schedule 的函数用于提交 task，内部有一个 tasks 的队列，Schedule 将 task 放入 tasks 的队列，ThreadPool 内部可以有多个 WorkerThread，从 tasks 队列中取任务（tasks 有锁保护）。">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/2024/08/mediapipe%E5%A6%82%E4%BD%95%E8%BF%90%E8%BD%AC/">
  <meta property="og:site_name" content="Manchey Blog">
  <meta property="og:title" content="Mediapipe如何运转">
  <meta property="og:description" content="Mediapipe 的版本 # 0.8.0
Mediapipe 的基本概念 # 参考：2024-06-17-Mediapipe调研
Mediapipe 有几个线程？ # 编译了 example 的 hello world，发现只有两类线程：
主线程，main 函数的线程，这个不用说了 Executor 线程，Mediapipe 默认只有一个 Executtor：ThreadPoolExecutor #include &#34;mediapipe/framework/calculator_graph.h&#34; #include &#34;mediapipe/framework/port/logging.h&#34; #include &#34;mediapipe/framework/port/parse_text_proto.h&#34; #include &#34;mediapipe/framework/port/status.h&#34; namespace mediapipe { ::mediapipe::Status PrintHelloWorld() { // Configures a simple graph, which concatenates 2 PassThroughCalculators. CalculatorGraphConfig config = ParseTextProtoOrDie&lt;CalculatorGraphConfig&gt;(R&#34;( input_stream: &#34;in&#34; output_stream: &#34;out&#34; node { calculator: &#34;PassThroughCalculator&#34; input_stream: &#34;in&#34; output_stream: &#34;out1&#34; } node { calculator: &#34;PassThroughCalculator&#34; input_stream: &#34;out1&#34; output_stream: &#34;out&#34; } )&#34;); CalculatorGraph graph; MP_RETURN_IF_ERROR(graph.Initialize(config)); ASSIGN_OR_RETURN(OutputStreamPoller poller, graph.AddOutputStreamPoller(&#34;out&#34;)); MP_RETURN_IF_ERROR(graph.StartRun({})); // Give 10 input packets that contains the same std::string &#34;Hello World!&#34;. for (int i = 0; i &lt; 100; &#43;&#43;i) { MP_RETURN_IF_ERROR(graph.AddPacketToInputStream( &#34;in&#34;, MakePacket&lt;std::string&gt;(&#34;Hello World!&#34;).At(Timestamp(i)))); sleep(3); } // Close the input stream &#34;in&#34;. MP_RETURN_IF_ERROR(graph.CloseInputStream(&#34;in&#34;)); mediapipe::Packet packet; // Get the output packets std::string. while (poller.Next(&amp;packet)) { std::cout &lt;&lt; &#34;Test: &#34; &lt;&lt; std::endl; LOG(ERROR) &lt;&lt; packet.Get&lt;std::string&gt;(); } return graph.WaitUntilDone(); } } // namespace mediapipe int main(int argc, char** argv) { std::cout &lt;&lt; &#34;main: &#34; &lt;&lt; std::endl; google::InitGoogleLogging(argv[0]); CHECK(mediapipe::PrintHelloWorld().ok()); return 0; } ThreadPoolExecutor 的实现 # 它就是一个简单的 ThreadPool，提供一个 Schedule 的函数用于提交 task，内部有一个 tasks 的队列，Schedule 将 task 放入 tasks 的队列，ThreadPool 内部可以有多个 WorkerThread，从 tasks 队列中取任务（tasks 有锁保护）。">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-08-09T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-08-09T00:00:00+00:00">
    <meta property="article:tag" content="Tech/Cpp/Scheduler/Mediapipe">
    <meta property="article:tag" content="非原创">
<title>Mediapipe如何运转 | Manchey Blog</title>
<link rel="icon" href="http://localhost:1313/logo.png" >
<link rel="manifest" href="http://localhost:1313/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/2024/08/mediapipe%E5%A6%82%E4%BD%95%E8%BF%90%E8%BD%AC/">
<link rel="stylesheet" href="http://localhost:1313/book.min.2d11051f9bbf9eb3c1e80b2b7a60b21379d1b88bdcc5a0c2b268ec9357d72f50.css" integrity="sha256-LREFH5u/nrPB6AsremCyE3nRuIvcxaDCsmjsk1fXL1A=" crossorigin="anonymous">
  <script defer src="http://localhost:1313/fuse.min.js"></script>
  <script defer src="http://localhost:1313/en.search.min.41873f4a8e861b1c2598929dd6c471abbce53c920d7f4046a555c40b88d9374c.js" integrity="sha256-QYc/So6GGxwlmJKd1sRxq7zlPJINf0BGpVXEC4jZN0w=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="http://localhost:1313/"><img src="http://localhost:1313/logo.png" alt="Logo" class="book-icon" /><span>Manchey Blog</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>























  
<ul>
  
  <li>
    <a href="http://localhost:1313/"  >
        Home
      </a>
  </li>
  
  <li>
    <a href="http://localhost:1313/post/"  >
        Blog
      </a>
  </li>
  
  <li>
    <a href="http://localhost:1313/about/"  >
        About
      </a>
  </li>
  
  <li>
    <a href="https://github.com/Manchey/manchey.github.io"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="http://localhost:1313/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Mediapipe如何运转</h3>

  <label for="toc-control">
    
    <img src="http://localhost:1313/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#mediapipe-的版本">Mediapipe 的版本</a></li>
    <li><a href="#mediapipe-的基本概念">Mediapipe 的基本概念</a></li>
    <li><a href="#mediapipe-有几个线程">Mediapipe 有几个线程？</a></li>
    <li><a href="#threadpoolexecutor-的实现">ThreadPoolExecutor 的实现</a></li>
    <li><a href="#calculatorgraph-有哪些成员变量">CalculatorGraph 有哪些成员变量？</a></li>
    <li><a href="#scheduler-和-executor-的关系是">Scheduler 和 Executor 的关系是？</a></li>
    <li><a href="#graph-是如何开始运转的">graph 是如何开始运转的？</a>
      <ul>
        <li><a href="#graphaddpackettoinputstream">graph.AddPacketToInputStream</a></li>
        <li><a href="#source-node">Source Node</a></li>
      </ul>
    </li>
    <li><a href="#inputstreamhandleroutputstreamhandleroutputstreammanagerinputstreammanager-的作用是">InputStreamHandler、OutputStreamHandler、OutputStreamManager、InputStreamManager 的作用是？</a></li>
    <li><a href="#calculatornode-和-calculator-是什么关系">CalculatorNode 和 Calculator 是什么关系？</a></li>
    <li><a href="#calculator-的-output-是如何到达-outputstreamhandler-的">Calculator 的 Output 是如何到达 OutputStreamHandler 的？</a></li>
    <li><a href="#上一个-calculator-的-output-是怎么传递到下一个-calculator-的-input">上一个 Calculator 的 Output 是怎么传递到下一个 Calculator 的 Input？</a></li>
    <li><a href="#什么时刻判断下一个-node-是否-ready如何放到-schedulequeue-中的">什么时刻判断下一个 Node 是否 Ready？如何放到 ScheduleQueue 中的？</a></li>
    <li><a href="#calculator-可以获得-input-stream-的所有数据吗">Calculator 可以获得 input stream 的所有数据吗？</a></li>
    <li><a href="#addpacket-的时候有一个-timestamp-是干嘛用的">AddPacket 的时候有一个 timestamp 是干嘛用的？</a></li>
    <li><a href="#side-packet-怎么用在哪里传入">side packet 怎么用？在哪里传入？</a></li>
    <li><a href="#back-edge-的作用是什么">back edge 的作用是什么？</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h2 id="mediapipe-的版本">
  Mediapipe 的版本
  <a class="anchor" href="#mediapipe-%e7%9a%84%e7%89%88%e6%9c%ac">#</a>
</h2>
<p>0.8.0</p>
<h2 id="mediapipe-的基本概念">
  Mediapipe 的基本概念
  <a class="anchor" href="#mediapipe-%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#</a>
</h2>
<p>参考：<a href="80_work/2024-06-17-Mediapipe%e8%b0%83%e7%a0%94.md">2024-06-17-Mediapipe调研</a></p>
<h2 id="mediapipe-有几个线程">
  Mediapipe 有几个线程？
  <a class="anchor" href="#mediapipe-%e6%9c%89%e5%87%a0%e4%b8%aa%e7%ba%bf%e7%a8%8b">#</a>
</h2>
<p>编译了 example 的 hello world，发现只有两类线程：</p>
<ol>
<li>主线程，main 函数的线程，这个不用说了</li>
<li>Executor 线程，Mediapipe 默认只有一个 Executtor：ThreadPoolExecutor</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;mediapipe/framework/calculator_graph.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;mediapipe/framework/port/logging.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;mediapipe/framework/port/parse_text_proto.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;mediapipe/framework/port/status.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> mediapipe {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">::</span>mediapipe<span style="color:#f92672">::</span>Status PrintHelloWorld() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Configures a simple graph, which concatenates 2 PassThroughCalculators.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  CalculatorGraphConfig config <span style="color:#f92672">=</span> ParseTextProtoOrDie<span style="color:#f92672">&lt;</span>CalculatorGraphConfig<span style="color:#f92672">&gt;</span>(R<span style="color:#e6db74">&#34;(</span>
</span></span><span style="display:flex;"><span>    input_stream: <span style="color:#e6db74">&#34;in&#34;</span>
</span></span><span style="display:flex;"><span>    output_stream: <span style="color:#e6db74">&#34;out&#34;</span>
</span></span><span style="display:flex;"><span>    node {
</span></span><span style="display:flex;"><span>      calculator: <span style="color:#e6db74">&#34;PassThroughCalculator&#34;</span>
</span></span><span style="display:flex;"><span>      input_stream: <span style="color:#e6db74">&#34;in&#34;</span>
</span></span><span style="display:flex;"><span>      output_stream: <span style="color:#e6db74">&#34;out1&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    node {
</span></span><span style="display:flex;"><span>      calculator: <span style="color:#e6db74">&#34;PassThroughCalculator&#34;</span>
</span></span><span style="display:flex;"><span>      input_stream: <span style="color:#e6db74">&#34;out1&#34;</span>
</span></span><span style="display:flex;"><span>      output_stream: <span style="color:#e6db74">&#34;out&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  )<span style="color:#e6db74">&#34;);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  CalculatorGraph graph;
</span></span><span style="display:flex;"><span>  MP_RETURN_IF_ERROR(graph.Initialize(config));
</span></span><span style="display:flex;"><span>  ASSIGN_OR_RETURN(OutputStreamPoller poller,
</span></span><span style="display:flex;"><span>                   graph.AddOutputStreamPoller(<span style="color:#e6db74">&#34;out&#34;</span>));
</span></span><span style="display:flex;"><span>  MP_RETURN_IF_ERROR(graph.StartRun({}));
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Give 10 input packets that contains the same std::string &#34;Hello World!&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    MP_RETURN_IF_ERROR(graph.AddPacketToInputStream(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;in&#34;</span>, MakePacket<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span>(<span style="color:#e6db74">&#34;Hello World!&#34;</span>).At(Timestamp(i))));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sleep(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Close the input stream &#34;in&#34;.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  MP_RETURN_IF_ERROR(graph.CloseInputStream(<span style="color:#e6db74">&#34;in&#34;</span>));
</span></span><span style="display:flex;"><span>  mediapipe<span style="color:#f92672">::</span>Packet packet;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get the output packets std::string.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (poller.Next(<span style="color:#f92672">&amp;</span>packet)) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Test: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    LOG(ERROR) <span style="color:#f92672">&lt;&lt;</span> packet.Get<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span>();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> graph.WaitUntilDone();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>}  <span style="color:#75715e">// namespace mediapipe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">**</span> argv) {
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  google<span style="color:#f92672">::</span>InitGoogleLogging(argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>  CHECK(mediapipe<span style="color:#f92672">::</span>PrintHelloWorld().ok());
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="threadpoolexecutor-的实现">
  ThreadPoolExecutor 的实现
  <a class="anchor" href="#threadpoolexecutor-%e7%9a%84%e5%ae%9e%e7%8e%b0">#</a>
</h2>
<p>它就是一个简单的 ThreadPool，提供一个 Schedule 的函数用于提交 task，内部有一个 tasks 的队列，Schedule 将 task 放入 tasks 的队列，ThreadPool 内部可以有多个 WorkerThread，从 tasks 队列中取任务（tasks 有锁保护）。</p>
<p>Executor 对外的接口是 AddTask，它会调用 Schedule 函数，所以新增自定义 Executor 就是重写 Schedule 函数。</p>
<p>Scheduler 中会调用 AddTask（严格来说是 ScheduleQueue）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Executor</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Executor();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// A registered Executor subclass must implement the static factory method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Create.  The Executor subclass cannot be registered without it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// static ::mediapipe::StatusOr&lt;Executor*&gt; Create(
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//     const MediaPipeOptions&amp; extendable_options);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Create validates extendable_options, then calls the constructor, and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// returns the newly allocated Executor object.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The scheduler queue calls this method to tell the executor that it has
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// a new task to run. The executor should use its execution mechanism to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// invoke task_queue-&gt;RunNextTask.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">AddTask</span>(TaskQueue<span style="color:#f92672">*</span> task_queue) {
</span></span><span style="display:flex;"><span>    Schedule([task_queue] { task_queue<span style="color:#f92672">-&gt;</span>RunNextTask(); });
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Schedule the specified &#34;task&#34; for execution in this executor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Schedule</span>(std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="calculatorgraph-有哪些成员变量">
  CalculatorGraph 有哪些成员变量？
  <a class="anchor" href="#calculatorgraph-%e6%9c%89%e5%93%aa%e4%ba%9b%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f">#</a>
</h2>
<p>关键成员变量：</p>
<ol>
<li>std::unique_ptr<!-- raw HTML omitted --> validated_graph_;，会将输入的 graph config 转成这种 validated graph，ValidatedGraphConfig 是一个 class</li>
</ol>
<p>graph 的重要组成元素：</p>
<p>基本下面三个成员就储存了整个 graph 的信息，CalculatorNode 是 graph 的点，input 和 output 是边，尤其是 OutputStreamManager 里面存储了 output stream 对应的 input stream 是哪些：</p>
<ol>
<li>std::unique_ptr&lt;InputStreamManager[]&gt; input_stream_managers_;</li>
<li>std::unique_ptr&lt;OutputStreamManager[]&gt; output_stream_managers_;</li>
<li>std::unique_ptr&lt;absl::FixedArray<!-- raw HTML omitted -->&gt; nodes_;</li>
</ol>
<p>Scheduler 和 Executor：</p>
<ol>
<li>std::map&lt;std::string, std::shared_ptr<!-- raw HTML omitted -->&gt; executors_;，这里可以有很多个 Executor，key 是 Executor 的 name</li>
<li>internal::Scheduler scheduler_;，这里还有一个 Scheduler，它也是运转的关键</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#75715e">// True if the graph was initialized.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> initialized_ <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// A packet type that has SetAny() called on it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  PacketType any_packet_type_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The ValidatedGraphConfig object defining this CalculatorGraph.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>ValidatedGraphConfig<span style="color:#f92672">&gt;</span> validated_graph_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The PacketGeneratorGraph to use to generate all the input side packets.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  PacketGeneratorGraph packet_generator_graph_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// True if the graph has source nodes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> has_sources_ <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// A flat array of InputStreamManager/OutputStreamManager/
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// OutputSidePacketImpl/CalculatorNode corresponding to the input/output
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// stream indexes, output side packet indexes, and calculator indexes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// respectively in validated_graph_.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Once allocated these structures must not be reallocated since
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// internal structures may point to individual entries in the array.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>InputStreamManager[]<span style="color:#f92672">&gt;</span> input_stream_managers_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>OutputStreamManager[]<span style="color:#f92672">&gt;</span> output_stream_managers_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>OutputSidePacketImpl[]<span style="color:#f92672">&gt;</span> output_side_packets_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>absl<span style="color:#f92672">::</span>FixedArray<span style="color:#f92672">&lt;</span>CalculatorNode<span style="color:#f92672">&gt;&gt;</span> nodes_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The graph output streams.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>internal<span style="color:#f92672">::</span>GraphOutputStream<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>      graph_output_streams_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Maximum queue size for an input stream. This is used by the scheduler to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// restrict memory usage.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> max_queue_size_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Mode for adding packets to a graph input stream. Set to block until all
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// affected input streams are not full by default.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  GraphInputStreamAddMode graph_input_stream_add_mode_
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(full_input_streams_mutex_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// For a source node or graph input stream (specified using id),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// this stores the set of dependent input streams that have hit their
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// maximum capacity. Graph input streams are also treated as nodes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// A node is scheduled only if this set is empty.  Similarly, a packet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// is added to a graph input stream only if this set is empty.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Note that this vector contains an unused entry for each non-source node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>absl<span style="color:#f92672">::</span>flat_hash_set<span style="color:#f92672">&lt;</span>InputStreamManager<span style="color:#f92672">*&gt;&gt;</span> full_input_streams_
</span></span><span style="display:flex;"><span>      ABSL_GUARDED_BY(full_input_streams_mutex_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Maps stream names to graph input stream objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  absl<span style="color:#f92672">::</span>flat_hash_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>GraphInputStream<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>      graph_input_streams_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Maps graph input streams to their virtual node ids.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  absl<span style="color:#f92672">::</span>flat_hash_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> graph_input_stream_node_ids_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Maps graph input streams to their max queue size.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  absl<span style="color:#f92672">::</span>flat_hash_map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> graph_input_stream_max_queue_size_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The factory for making counters associated with this graph.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>CounterFactory<span style="color:#f92672">&gt;</span> counter_factory_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Executors for the scheduler, keyed by the executor&#39;s name. The default
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// executor&#39;s name is the empty std::string.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Executor<span style="color:#f92672">&gt;&gt;</span> executors_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The processed input side packet map for this run.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, Packet<span style="color:#f92672">&gt;</span> current_run_side_packets_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, Packet<span style="color:#f92672">&gt;</span> service_packets_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Vector of errors encountered while running graph. Always use RecordError()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// to add an error to this vector.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;::</span>mediapipe<span style="color:#f92672">::</span>Status<span style="color:#f92672">&gt;</span> errors_ ABSL_GUARDED_BY(error_mutex_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// True if the default executor uses the application thread.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> use_application_thread_ <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Condition variable that waits until all input streams that depend on a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// graph input stream are below the maximum queue size.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  absl<span style="color:#f92672">::</span>CondVar wait_to_add_packet_cond_var_
</span></span><span style="display:flex;"><span>      ABSL_GUARDED_BY(full_input_streams_mutex_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Mutex for the vector of errors.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  absl<span style="color:#f92672">::</span>Mutex error_mutex_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Status variable to indicate if the graph has encountered an error.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> has_error_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Mutex for full_input_streams_.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">mutable</span> absl<span style="color:#f92672">::</span>Mutex full_input_streams_mutex_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Number of closed graph input streams. This is a separate variable because
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// it is not safe to hold a lock on the scheduler while calling Close() on an
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// input stream. Hence, we decouple the closing of the stream and checking its
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// status.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// TODO: update this comment.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> num_closed_graph_input_streams_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The graph tracing and profiling interface.  It is owned by the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// CalculatorGraph using a shared_ptr in order to allow threadsafe access
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// to the ProfilingContext from clients that may outlive the CalculatorGraph
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// such as GlContext.  It is declared here before the Scheduler so that it
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// remains available during the Scheduler destructor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>ProfilingContext<span style="color:#f92672">&gt;</span> profiler_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  internal<span style="color:#f92672">::</span>Scheduler scheduler_;
</span></span></code></pre></div><h2 id="scheduler-和-executor-的关系是">
  Scheduler 和 Executor 的关系是？
  <a class="anchor" href="#scheduler-%e5%92%8c-executor-%e7%9a%84%e5%85%b3%e7%b3%bb%e6%98%af">#</a>
</h2>
<p>下面是 Scheduler 的成员变量，关键的变量：</p>
<ol>
<li>CalculatorGraph* graph_;，graph 和 Scheduler 的关系是你中有我、我中有你，所以实际它俩是作为一个 bazel target 来编译的（不这样也编译不过，它俩影响了环形依赖）</li>
<li>SchedulerQueue default_queue_;，默认调度队列，如果使用的默认的 ThreadPoolExecutor，那就用这个队列，Scheduler 会从这个队列中取 task，将其提交给 ThreadPoolExecutor</li>
<li>std::map&lt;std::string, std::unique_ptr<!-- raw HTML omitted -->&gt; non_default_queues_;，如果有注册新的 Executor，那么每个 Executor 对应一个调度队列，key 是 Executor name</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#75715e">// The calculator graph to run.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  CalculatorGraph<span style="color:#f92672">*</span> graph_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Data accessed by all SchedulerQueues.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  SchedulerShared shared_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Queue of nodes that need to be run.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  SchedulerQueue default_queue_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Non-default scheduler queues, keyed by their executor names.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>map<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string, std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>SchedulerQueue<span style="color:#f92672">&gt;&gt;</span> non_default_queues_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Holds pointers to all queues used by the scheduler, for convenience.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>SchedulerQueue<span style="color:#f92672">*&gt;</span> scheduler_queues_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Priority queue of source nodes ordered by layer and then source process
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// order. This stores the set of sources that are yet to be run.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>priority_queue<span style="color:#f92672">&lt;</span>SchedulerQueue<span style="color:#f92672">::</span>Item<span style="color:#f92672">&gt;</span> sources_queue_
</span></span><span style="display:flex;"><span>      ABSL_GUARDED_BY(state_mutex_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Source nodes with the smallest source layer are at the beginning of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// unopened_sources_. Before the scheduler is started, all source nodes are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// added to unopened_sources_. Once the scheduler starts running,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// unopened_sources_ should only be accessed under the protection of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// state_mutex_. A source node is removed from unopened_sources_ after it is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// opened.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>set<span style="color:#f92672">&lt;</span>CalculatorNode<span style="color:#f92672">*</span>, SourceLayerCompare<span style="color:#f92672">&gt;</span> unopened_sources_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Keeps track of sources that can be considered for scheduling. Sources are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// scheduled in layers, and those that are not currently active will not be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// scheduled even if ready. Sources are removed once they are closed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>CalculatorNode<span style="color:#f92672">*&gt;</span> active_sources_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Condition variable used to wait for some changes to the scheduler state.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// These correspond to the Wait* methods in this class.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Not all state changes need to signal this, only those that enter one of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// the waitable states.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  absl<span style="color:#f92672">::</span>CondVar state_cond_var_ ABSL_GUARDED_BY(state_mutex_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Number of queues which are not idle.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Note: this indicates two slightly different things:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  a. the number of queues which still have nodes running;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//  b. the number of queues whose executors may still access the scheduler.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// When a queue becomes idle, it has stopped running nodes, and the scheduler
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// decrements the count. However, it is not done accessing the scheduler
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// until HandleIdle returns. Therefore, a and b are briefly out of sync.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// This is ok, because it happens within a single critical section, which is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// guarded by state_mutex_. If we wanted to split this critical section, we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// would have to separate a and b into two variables.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> non_idle_queue_count_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(state_mutex_) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Tasks to be executed on the application thread.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>deque<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&gt;</span> app_thread_tasks_
</span></span><span style="display:flex;"><span>      ABSL_GUARDED_BY(state_mutex_);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Used by HandleIdle to avoid multiple concurrent executions.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// We cannot simply hold a mutex throughout it, for two reasons:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// - We need it to be reentrant, which Mutex does not support.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// - We want simultaneous calls to return immediately instead of waiting,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//   and Mutex&#39;s TryLock is not guaranteed to work.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> handling_idle_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(state_mutex_) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Mutex for the scheduler state and related things.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Note: state_ is declared as atomic so that its getter methods don&#39;t need
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// to acquire state_mutex_.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  absl<span style="color:#f92672">::</span>Mutex state_mutex_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Current state of the scheduler.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>atomic<span style="color:#f92672">&lt;</span>State<span style="color:#f92672">&gt;</span> state_ <span style="color:#f92672">=</span> ATOMIC_VAR_INIT(STATE_NOT_STARTED);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// True if all graph input streams are closed.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> graph_input_streams_closed_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(state_mutex_) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Number of throttled graph input streams.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> throttled_graph_input_stream_count_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(state_mutex_) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Used to stop WaitUntilGraphInputStreamUnthrottled.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> unthrottle_seq_num_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(state_mutex_) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Used to stop WaitForObservedOutput.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> observed_output_signal_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(state_mutex_) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// True if an application thread is waiting in WaitForObservedOutput.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> waiting_for_observed_output_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(state_mutex_) <span style="color:#f92672">=</span> false;
</span></span></code></pre></div><h2 id="graph-是如何开始运转的">
  graph 是如何开始运转的？
  <a class="anchor" href="#graph-%e6%98%af%e5%a6%82%e4%bd%95%e5%bc%80%e5%a7%8b%e8%bf%90%e8%bd%ac%e7%9a%84">#</a>
</h2>
<p>有两种方式：</p>
<ol>
<li>一种是调用 graph.AddPacketToInputStream，给 graph 灌入数据，然后 graph 开始执行</li>
<li>一种是 Source Node，没有 input，有 output，它会产生数据，让 graph 运转起来</li>
</ol>
<h3 id="graphaddpackettoinputstream">
  graph.AddPacketToInputStream
  <a class="anchor" href="#graphaddpackettoinputstream">#</a>
</h3>
<p>关键的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>  <span style="color:#75715e">// InputStreamManager is thread safe. GraphInputStream is not, so this method
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// should not be called by multiple threads concurrently. Note that this could
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// potentially lead to the max queue size being exceeded by one packet at most
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// because we don&#39;t have the lock over the input stream.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  (<span style="color:#f92672">*</span>stream)<span style="color:#f92672">-&gt;</span>AddPacket(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(packet));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (has_error_) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">::</span>mediapipe<span style="color:#f92672">::</span>Status error_status;
</span></span><span style="display:flex;"><span>    GetCombinedErrors(<span style="color:#e6db74">&#34;Graph has errors: &#34;</span>, <span style="color:#f92672">&amp;</span>error_status);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> error_status;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  (<span style="color:#f92672">*</span>stream)<span style="color:#f92672">-&gt;</span>PropagateUpdatesToMirrors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  VLOG(<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Packet added directly to: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> stream_name;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Note: one reason why we need to call the scheduler here is that we have
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// re-throttled the graph input streams, and we may need to unthrottle them
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// again if the graph is still idle. Unthrottling basically only lets in one
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// packet at a time. TODO: add test.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  scheduler_.AddedPacketToGraphInputStream();
</span></span></code></pre></div><ol>
<li>stream，它是从 graph_input_streams_ 中查找出来的</li>
<li>(*stream)-&gt;AddPacket(std::forward<!-- raw HTML omitted -->(packet));，将 packet 放入队列，实际是直接放入了 OutputStreamHandler 的队列，就好像有一个透明的 Calculator 一样</li>
<li>(*stream)-&gt;PropagateUpdatesToMirrors();</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> CalculatorGraph<span style="color:#f92672">::</span>GraphInputStream<span style="color:#f92672">::</span>PropagateUpdatesToMirrors() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Since GraphInputStream doesn&#39;t allow SetOffset() and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// SetNextTimestampBound(), the timestamp bound to propagate is only
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// determined by the timestamp of the output packets.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  CHECK(<span style="color:#f92672">!</span>shard_.IsEmpty()) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Shard with name </span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">&lt;&lt;</span> manager_<span style="color:#f92672">-&gt;</span>Name()
</span></span><span style="display:flex;"><span>                           <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74"> failed&#34;</span>;
</span></span><span style="display:flex;"><span>  manager_<span style="color:#f92672">-&gt;</span>PropagateUpdatesToMirrors(
</span></span><span style="display:flex;"><span>      shard_.LastAddedPacketTimestamp().NextAllowedInStream(), <span style="color:#f92672">&amp;</span>shard_);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>manager_ 实际是一个 OutputStreamManager，它的 PropagateUpdatesToMirrors 实际上会将 OutputStreamShard 的 packets 取出来，放到 mirror 中保存的 InputStreamHandler 中</p>
<p><img src="assets/4888fff4d77affb467a113ad8559c2ae_MD5.png" alt="" /></p>
<h3 id="source-node">
  Source Node
  <a class="anchor" href="#source-node">#</a>
</h3>
<p>待查看</p>
<h2 id="inputstreamhandleroutputstreamhandleroutputstreammanagerinputstreammanager-的作用是">
  InputStreamHandler、OutputStreamHandler、OutputStreamManager、InputStreamManager 的作用是？
  <a class="anchor" href="#inputstreamhandleroutputstreamhandleroutputstreammanagerinputstreammanager-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af">#</a>
</h2>
<p>两个 Calculator 是通过 stream 进行“链接”，分为：InputStream 和 OutputStream。</p>
<p>InputStreamHandler 有一个功能就是判断 Calculator 是否 Ready，Ready 的话就可以将 Calculator 放入 ScheduleQueue，它类的解释：</p>
<p><img src="assets/2faf2a4447bcec3e9a5f6c3380fe06d5_MD5.png" alt="" /></p>
<p>它内部包含了一个 InputStreamManager Set，看起来像是从 CalculatorGraph 的成员变量赋值过来的，给过来的是一个指针的 Set</p>
<p>InputStreamManager 的类解释：</p>
<p><img src="assets/40fb62dd848d94e8d54fa7d76453900e_MD5.png" alt="" /></p>
<p>OutputStreamHandler：</p>
<p>它里面也是包含了一个 OutputStreamManager Set，看起来也是从 CalculatorGraph 的成员变量赋值过来的：</p>
<p><img src="99_%E6%9C%AA%E5%BD%92%E6%A1%A3/assets/f8b70808a1596a50fc2277eb4698573a_MD5.png" alt="" /></p>
<p>OutputStreamManager：</p>
<p><img src="99_%E6%9C%AA%E5%BD%92%E6%A1%A3/assets/4788b1397ac9e9eae06344ada11d7f20_MD5.png" alt="" /></p>
<h2 id="calculatornode-和-calculator-是什么关系">
  CalculatorNode 和 Calculator 是什么关系？
  <a class="anchor" href="#calculatornode-%e5%92%8c-calculator-%e6%98%af%e4%bb%80%e4%b9%88%e5%85%b3%e7%b3%bb">#</a>
</h2>
<p>从 CalculatorGraph 的成员变量看，它是存储的 CalculatorNode，Scheduler 调度的时候也是调度的 CalculatorNode，那么它和 Calculator 的关系是？</p>
<p>看一下 CalculatorNode 的成员变量，关键的变量：</p>
<ol>
<li>std::unique_ptr<!-- raw HTML omitted --> calculator_;——它会包含 Calculator 的 unique_ptr</li>
<li>CalculatorContextManager calculator_context_manager_;——这里实际是获取 Calculator 的 Context</li>
<li>std::unique_ptr<!-- raw HTML omitted --> input_stream_handler_;——管理 input stream</li>
<li>std::unique_ptr<!-- raw HTML omitted --> output_stream_handler_;——管理 output stream</li>
<li>internal::SchedulerQueue* scheduler_queue_ = nullptr;——CalculatorNode 所在的调度队列</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// The calculator.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>CalculatorBase<span style="color:#f92672">&gt;</span> calculator_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Keeps data which a Calculator subclass needs access to.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>CalculatorState<span style="color:#f92672">&gt;</span> calculator_state_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> node_id_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>string name_;  <span style="color:#75715e">// Optional user-defined name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Name of the executor which the node will execute on. If empty, the node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// will execute on the default executor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>string executor_;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The layer a source calculator operates on.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> source_layer_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The status of the current Calculator that this CalculatorNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// is wrapping.  kStateActive is currently used only for source nodes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">NodeStatus</span> {
</span></span><span style="display:flex;"><span>    kStateUninitialized <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    kStatePrepared <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    kStateOpened <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>    kStateActive <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>    kStateClosed <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  NodeStatus status_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(status_mutex_){kStateUninitialized};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The max number of invocations that can be scheduled in parallel.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> max_in_flight_ <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// The following two variables are used for the concurrency control of node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// scheduling.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// The number of invocations that are scheduled but not finished.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> current_in_flight_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(status_mutex_) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// SchedulingState incidates the current state of the node scheduling process.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// There are four possible transitions:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// (a) From kIdle to kScheduling.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Any thread that makes this transition becomes the scheduling thread and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// will be responsible for preparing and scheduling all possible invocations.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// (b) From kScheduling to kSchedulingPending.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Any thread, except the scheduling thread, can make this transition.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// kSchedulingPending indicates that some recent changes require the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// scheduling thread to recheck the node readiness after current scheduling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// iteration.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// (c) From kSchedulingPending to kScheduling.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Made by the scheduling thread to indicate that it has already caught up
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// with all the recent changes that can affect node readiness.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// (d) From kScheduling to kIdle. Made by the scheduling thread when there is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// no more scheduling work to be done.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">SchedulingState</span> {
</span></span><span style="display:flex;"><span>    kIdle <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,        <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    kScheduling <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,  <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    kSchedulingPending <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  SchedulingState scheduling_state_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(status_mutex_) <span style="color:#f92672">=</span> kIdle;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> ready_for_open_callback_;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> source_node_opened_callback_;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> input_stream_headers_ready_called_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(status_mutex_) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> input_side_packets_ready_called_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(status_mutex_) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> input_stream_headers_ready_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(status_mutex_) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> input_side_packets_ready_ <span style="color:#a6e22e">ABSL_GUARDED_BY</span>(status_mutex_) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Owns and manages all CalculatorContext objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  CalculatorContextManager calculator_context_manager_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>ProfilingContext<span style="color:#f92672">&gt;</span> profiling_context_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Mutex for node status.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">mutable</span> absl<span style="color:#f92672">::</span>Mutex status_mutex_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Manages the set of input side packets.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  InputSidePacketHandler input_side_packet_handler_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Collection of all OutputSidePacket objects.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>OutputSidePacketSet<span style="color:#f92672">&gt;</span> output_side_packets_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>InputStreamHandler<span style="color:#f92672">&gt;</span> input_stream_handler_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>OutputStreamHandler<span style="color:#f92672">&gt;</span> output_stream_handler_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Whether this is a GPU calculator.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> uses_gpu_ <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// True if CleanupAfterRun() needs to call CloseNode().
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">bool</span> needs_to_close_ <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  internal<span style="color:#f92672">::</span>SchedulerQueue<span style="color:#f92672">*</span> scheduler_queue_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> ValidatedGraphConfig<span style="color:#f92672">*</span> validated_graph_ <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span></code></pre></div><p>在 CalculatorGraph 初始化的时候，会创建一个 CalculatorNode 的集合，每个 Node 会调用一下初始化函数，初始化时，会将 input_stream_managers_ 和 output_stream_managers_ 传递进去，在 CalculatorNode::Initialize 函数中初始化了 inputstream 和 outputstream 的：</p>
<p><img src="assets/4ddb567bb953035776ed98235164c58f_MD5.png" alt="" /></p>
<p>而在 CalculatorNode::PrepareForRun 再创建的 Calculator 的 uniuqe_ptr。</p>
<h2 id="calculator-的-output-是如何到达-outputstreamhandler-的">
  Calculator 的 Output 是如何到达 OutputStreamHandler 的？
  <a class="anchor" href="#calculator-%e7%9a%84-output-%e6%98%af%e5%a6%82%e4%bd%95%e5%88%b0%e8%be%be-outputstreamhandler-%e7%9a%84">#</a>
</h2>
<p>CalculatorContext 的 Outputs 接口定义：<code>OutputStreamShardSet&amp; Outputs();</code>，它返回的是一个 OutputStreamShardSet，返回的是 CalculatorContext 内部的 outputs_：</p>
<p><img src="assets/4917f42cafb351389aca20512422e0f5_MD5.png" alt="" /></p>
<p>它是外部传进来的：</p>
<p><img src="99_%E6%9C%AA%E5%BD%92%E6%A1%A3/assets/f23c220ab61a6b890f5a04af17090952_MD5.png" alt="" /></p>
<p>CalculatorContext 是什么时期创建的？</p>
<p>CalculatorContext 是由 CalculatorContextManager 管理的（默认是一对一），而每个 CalculatorNode 有一个自己的 CalculatorContextManager，它在 CalculatorNode 构造时构造的，在 CalculatorNode 初始化时，将 input stream 和 output stream 赋值到了 CalculatorContextManager 中。</p>
<p>但是 CalculatorContext 中存的只是 OutputStreamShard，它和 OutputStreamHandler 是什么关系？</p>
<p>在 CalculatorNode::ProcessNode 函数中，执行了 Calculator 的 Process 函数，之后会调用一下 output_stream_handler 的 PostProcess 函数，至此终于将 Calculator 的 Output 和 OutputStreamHandler 关联上了：</p>
<p><img src="assets/f86e71716d922e0780ea91548b08a04f_MD5.png" alt="" /></p>
<h2 id="上一个-calculator-的-output-是怎么传递到下一个-calculator-的-input">
  上一个 Calculator 的 Output 是怎么传递到下一个 Calculator 的 Input？
  <a class="anchor" href="#%e4%b8%8a%e4%b8%80%e4%b8%aa-calculator-%e7%9a%84-output-%e6%98%af%e6%80%8e%e4%b9%88%e4%bc%a0%e9%80%92%e5%88%b0%e4%b8%8b%e4%b8%80%e4%b8%aa-calculator-%e7%9a%84-input">#</a>
</h2>
<p>关键还是上面的 OutputStreamHandler 的 PostProcess：它里面调用了 OutputStreamManager 的 PropagateUpdatesToMirrors，这个函数内部会将 packets 转给对应的 input_stream_handler：</p>
<p><img src="assets/52386f0f79cfc165329383bc5681b15f_MD5.png" alt="" /></p>
<p><img src="assets/d64909a48f88c3360ad1bf90dbbf1ba6_MD5.png" alt="" /></p>
<p><img src="assets/48d674b988904a33e2bac7850e08b04b_MD5.png" alt="" /></p>
<p>经过几处辗转，调用了 InputStreamHandler::ScheduleInvocations，它会判断 node_readiness = GetNodeReadiness 是否 Ready：</p>
<p><img src="assets/0d8240185ae301828e43d83df542d625_MD5.png" alt="" /></p>
<p>如果 Ready 的话，就会调用 FillInputSet，将存储在 InputStreamManager 中的 Packet 填入到 Calculator 的 InputStreamShard：</p>
<p><img src="assets/f04075ec83e7aa4c236eb9af33783643_MD5.png" alt="" /></p>
<h2 id="什么时刻判断下一个-node-是否-ready如何放到-schedulequeue-中的">
  什么时刻判断下一个 Node 是否 Ready？如何放到 ScheduleQueue 中的？
  <a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%97%b6%e5%88%bb%e5%88%a4%e6%96%ad%e4%b8%8b%e4%b8%80%e4%b8%aa-node-%e6%98%af%e5%90%a6-ready%e5%a6%82%e4%bd%95%e6%94%be%e5%88%b0-schedulequeue-%e4%b8%ad%e7%9a%84">#</a>
</h2>
<p>接上文，在 input_stream_handler 的 MovePackets 和 AddPackets 都会判断一下是否 Ready，具体是下面的 notification_()：</p>
<p><img src="assets/f0c2c889eaf47de6cd3765b88fed5e97_MD5.png" alt="" /></p>
<p>在 CalculatorGraph::PrepareForRun 函数中，调用了 Node 的 PrepareForRun 函数：</p>
<p><img src="assets/ec7f45e0319abd8f11d51a088856902d_MD5.png" alt="" /></p>
<p>Node 的 PrepareForRun 函数中给 input_stream_handler 注册了 notification 的回调函数是：CheckIfBecameReady</p>
<p><img src="assets/5b65de850af9a84b699070226e885073_MD5.png" alt="" /></p>
<p>在 CheckIfBecameReady 函数中会调用调度函数：SchedulingLoop-&gt;input_stream_handler_-&gt;ScheduleInvocations</p>
<p><img src="assets/3717eb7a3318b8129f4252637a55a4e6_MD5.png" alt="" /></p>
<p>input_stream_handler_-&gt;ScheduleInvocations 中会调用 schedule_callback_ 回调函数，而这个 schedule_callback_ 回调是 CalculatorNode 给赋值的：</p>
<p><img src="assets/756e93981fb5ae845acdca8db44ef154_MD5.png" alt="" /></p>
<p>而 CalculatorNode 的回调是 CalculatorGraph 赋值的，实际是 Scheduler::ScheduleNodeIfNotThrottled</p>
<p><img src="assets/d1bc471be1678f4cb59b949195dceb8a_MD5.png" alt="" /></p>
<p>总结：每次 Node 通过 Output 向下传递数据时，都会到下游的 InputStreamHandler，它会判断 Node 是否 Ready，如果 Ready 则会将 CalculatorNode 放入 ScheduleQueue，同时会从 ScheduleQueue 中根据优先级取出下一个要执行的 CalculatorNode 封装成 Task 提交给 Executor。</p>
<h2 id="calculator-可以获得-input-stream-的所有数据吗">
  Calculator 可以获得 input stream 的所有数据吗？
  <a class="anchor" href="#calculator-%e5%8f%af%e4%bb%a5%e8%8e%b7%e5%be%97-input-stream-%e7%9a%84%e6%89%80%e6%9c%89%e6%95%b0%e6%8d%ae%e5%90%97">#</a>
</h2>
<p>是不行的，看起来只能访问最旧的消息，那在 graph 的 source node 或者 input 输入时要做流控，不然总是消费最旧的数据：</p>
<p><img src="assets/e049d4d1209874671c0e3577e6255e41_MD5.png" alt="" /></p>
<h2 id="addpacket-的时候有一个-timestamp-是干嘛用的">
  AddPacket 的时候有一个 timestamp 是干嘛用的？
  <a class="anchor" href="#addpacket-%e7%9a%84%e6%97%b6%e5%80%99%e6%9c%89%e4%b8%80%e4%b8%aa-timestamp-%e6%98%af%e5%b9%b2%e5%98%9b%e7%94%a8%e7%9a%84">#</a>
</h2>
<p>既像时间戳，又像是 sequence num，在判断 Node 是否 Ready 的时候会通过 timestamp 来判断，下面是 DefaultInputStreamHandler 的判断是否 Ready 的函数：</p>
<p>看起来要求 timestamp 是严格递增的，如果不递增会在判断 Ready 时不被处理。</p>
<p><img src="assets/e0e75a236b1822091a8475bb3dcac258_MD5.png" alt="" /></p>
<h2 id="side-packet-怎么用在哪里传入">
  side packet 怎么用？在哪里传入？
  <a class="anchor" href="#side-packet-%e6%80%8e%e4%b9%88%e7%94%a8%e5%9c%a8%e5%93%aa%e9%87%8c%e4%bc%a0%e5%85%a5">#</a>
</h2>
<p>可以写一个特殊的 Calculator，然后将配置文件的内容转为 side packet，或者直接调用 graph 的接口传入：</p>
<p><img src="assets/d5fbe0c9e638057784e69bf5c7bf541d_MD5.png" alt="" /></p>
<h2 id="back-edge-的作用是什么">
  back edge 的作用是什么？
  <a class="anchor" href="#back-edge-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88">#</a>
</h2>
<p>见下面的章节：</p>
<p><a href="https://rqk9rsooi4.feishu.cn/wiki/WvQBw89QZiNiGPkG2JDcjdFunad#S5vmdw2eaoXlGOxcTtgc8Ttdnmb">2024/06/17 Mediapipe调研</a></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#mediapipe-的版本">Mediapipe 的版本</a></li>
    <li><a href="#mediapipe-的基本概念">Mediapipe 的基本概念</a></li>
    <li><a href="#mediapipe-有几个线程">Mediapipe 有几个线程？</a></li>
    <li><a href="#threadpoolexecutor-的实现">ThreadPoolExecutor 的实现</a></li>
    <li><a href="#calculatorgraph-有哪些成员变量">CalculatorGraph 有哪些成员变量？</a></li>
    <li><a href="#scheduler-和-executor-的关系是">Scheduler 和 Executor 的关系是？</a></li>
    <li><a href="#graph-是如何开始运转的">graph 是如何开始运转的？</a>
      <ul>
        <li><a href="#graphaddpackettoinputstream">graph.AddPacketToInputStream</a></li>
        <li><a href="#source-node">Source Node</a></li>
      </ul>
    </li>
    <li><a href="#inputstreamhandleroutputstreamhandleroutputstreammanagerinputstreammanager-的作用是">InputStreamHandler、OutputStreamHandler、OutputStreamManager、InputStreamManager 的作用是？</a></li>
    <li><a href="#calculatornode-和-calculator-是什么关系">CalculatorNode 和 Calculator 是什么关系？</a></li>
    <li><a href="#calculator-的-output-是如何到达-outputstreamhandler-的">Calculator 的 Output 是如何到达 OutputStreamHandler 的？</a></li>
    <li><a href="#上一个-calculator-的-output-是怎么传递到下一个-calculator-的-input">上一个 Calculator 的 Output 是怎么传递到下一个 Calculator 的 Input？</a></li>
    <li><a href="#什么时刻判断下一个-node-是否-ready如何放到-schedulequeue-中的">什么时刻判断下一个 Node 是否 Ready？如何放到 ScheduleQueue 中的？</a></li>
    <li><a href="#calculator-可以获得-input-stream-的所有数据吗">Calculator 可以获得 input stream 的所有数据吗？</a></li>
    <li><a href="#addpacket-的时候有一个-timestamp-是干嘛用的">AddPacket 的时候有一个 timestamp 是干嘛用的？</a></li>
    <li><a href="#side-packet-怎么用在哪里传入">side packet 怎么用？在哪里传入？</a></li>
    <li><a href="#back-edge-的作用是什么">back edge 的作用是什么？</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












