<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  背景&amp;需求&amp;目的
  #


  方案
  #


用户接口：

主要：Component &#43; TimerComponent
额外：Reader callback, Async


任务图搭建：通过 channel 组成 DAG，提供 AllLatest 数据同步策略
调度：ClassicScheduler &#43; ChoreographyScheduler，用协程包装用户任务
通信：intra &#43; shm &#43; dds，非在线模式 blocker


  用户接口（任务类型）
  #


  数据驱动任务 Component
  #



代码中写明类型，实现自己的初始化、数据处理、反初始化（可选）逻辑


配置文件中指定 channel 名称
class CommonComponentSample : public Component&lt;Driver, Driver&gt; {
 public:
  bool Init() override;
  bool Proc(const std::shared_ptr&lt;Driver&gt;&amp; msg0,
            const std::shared_ptr&lt;Driver&gt;&amp; msg1) override;
};
CYBER_REGISTER_COMPONENT(CommonComponentSample)
    components {
        class_name : &#34;CommonComponentSample&#34;
        config {
            name : &#34;common&#34;
            readers {
                channel: &#34;/apollo/prediction&#34;
            }
            readers {
                channel: &#34;/apollo/test&#34;
            }
        }



  时间驱动任务 TimerComponent
  #



代码中实现定时处理逻辑">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/posts/2024/07/cyberrt%E8%B0%83%E5%BA%A6%E8%B0%83%E7%A0%94/">
  <meta property="og:site_name" content="Manchey Blog">
  <meta property="og:title" content="CyberRT调度调研">
  <meta property="og:description" content="背景&amp;需求&amp;目的 # 方案 # 用户接口： 主要：Component &#43; TimerComponent 额外：Reader callback, Async 任务图搭建：通过 channel 组成 DAG，提供 AllLatest 数据同步策略 调度：ClassicScheduler &#43; ChoreographyScheduler，用协程包装用户任务 通信：intra &#43; shm &#43; dds，非在线模式 blocker 用户接口（任务类型） # 数据驱动任务 Component # 代码中写明类型，实现自己的初始化、数据处理、反初始化（可选）逻辑
配置文件中指定 channel 名称
class CommonComponentSample : public Component&lt;Driver, Driver&gt; { public: bool Init() override; bool Proc(const std::shared_ptr&lt;Driver&gt;&amp; msg0, const std::shared_ptr&lt;Driver&gt;&amp; msg1) override; }; CYBER_REGISTER_COMPONENT(CommonComponentSample) components { class_name : &#34;CommonComponentSample&#34; config { name : &#34;common&#34; readers { channel: &#34;/apollo/prediction&#34; } readers { channel: &#34;/apollo/test&#34; } } 时间驱动任务 TimerComponent # 代码中实现定时处理逻辑">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-07-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-07-24T00:00:00+00:00">
    <meta property="article:tag" content="Tech/Cpp/Scheduler/Cyberrt">
    <meta property="article:tag" content="Blog">
<title>CyberRT调度调研 | Manchey Blog</title>
<link rel="icon" href="http://localhost:1313/logo.png" >
<link rel="manifest" href="http://localhost:1313/manifest.json">
<link rel="canonical" href="http://localhost:1313/posts/2024/07/cyberrt%E8%B0%83%E5%BA%A6%E8%B0%83%E7%A0%94/">
<link rel="stylesheet" href="http://localhost:1313/book.min.2d11051f9bbf9eb3c1e80b2b7a60b21379d1b88bdcc5a0c2b268ec9357d72f50.css" integrity="sha256-LREFH5u/nrPB6AsremCyE3nRuIvcxaDCsmjsk1fXL1A=" crossorigin="anonymous">
  <script defer src="http://localhost:1313/fuse.min.js"></script>
  <script defer src="http://localhost:1313/en.search.min.41873f4a8e861b1c2598929dd6c471abbce53c920d7f4046a555c40b88d9374c.js" integrity="sha256-QYc/So6GGxwlmJKd1sRxq7zlPJINf0BGpVXEC4jZN0w=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="http://localhost:1313/"><img src="http://localhost:1313/logo.png" alt="Logo" class="book-icon" /><span>Manchey Blog</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>























  
<ul>
  
  <li>
    <a href="http://localhost:1313/"  >
        Home
      </a>
  </li>
  
  <li>
    <a href="http://localhost:1313/post/"  >
        Blog
      </a>
  </li>
  
  <li>
    <a href="http://localhost:1313/about/"  >
        About
      </a>
  </li>
  
  <li>
    <a href="https://github.com/Manchey/manchey.github.io"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="http://localhost:1313/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>CyberRT调度调研</h3>

  <label for="toc-control">
    
    <img src="http://localhost:1313/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#背景需求目的">背景&amp;需求&amp;目的</a></li>
    <li><a href="#方案">方案</a>
      <ul>
        <li><a href="#用户接口任务类型">用户接口（任务类型）</a></li>
        <li><a href="#任务图搭建">任务图搭建</a></li>
        <li><a href="#调度">调度</a></li>
      </ul>
    </li>
    <li><a href="#processor">Processor</a>
      <ul>
        <li><a href="#协程">协程</a></li>
        <li><a href="#任务对应的协程">任务对应的协程</a></li>
      </ul>
    </li>
    <li><a href="#scheduler-相关代码结构">scheduler 相关代码结构</a></li>
    <li><a href="#附录">附录</a>
      <ul>
        <li><a href="#线程情况">线程情况</a></li>
        <li><a href="#和-mediapipetaskflow-对比">和 mediapipe、Taskflow 对比</a></li>
        <li><a href="#reference">reference</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h2 id="背景需求目的">
  背景&amp;需求&amp;目的
  <a class="anchor" href="#%e8%83%8c%e6%99%af%e9%9c%80%e6%b1%82%e7%9b%ae%e7%9a%84">#</a>
</h2>
<h2 id="方案">
  方案
  <a class="anchor" href="#%e6%96%b9%e6%a1%88">#</a>
</h2>
<ul>
<li>用户接口：
<ul>
<li>主要：Component + TimerComponent</li>
<li>额外：Reader callback, Async</li>
</ul>
</li>
<li>任务图搭建：通过 channel 组成 DAG，提供 AllLatest 数据同步策略</li>
<li>调度：ClassicScheduler + ChoreographyScheduler，用协程包装用户任务</li>
<li>通信：intra + shm + dds，非在线模式 blocker</li>
</ul>
<h3 id="用户接口任务类型">
  用户接口（任务类型）
  <a class="anchor" href="#%e7%94%a8%e6%88%b7%e6%8e%a5%e5%8f%a3%e4%bb%bb%e5%8a%a1%e7%b1%bb%e5%9e%8b">#</a>
</h3>
<h4 id="数据驱动任务-component">
  数据驱动任务 Component
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%e4%bb%bb%e5%8a%a1-component">#</a>
</h4>
<ul>
<li>
<p>代码中写明类型，实现自己的初始化、数据处理、反初始化（可选）逻辑</p>
</li>
<li>
<p>配置文件中指定 channel 名称</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CommonComponentSample</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Component<span style="color:#f92672">&lt;</span>Driver, Driver<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> Init() <span style="color:#66d9ef">override</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Proc</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Driver<span style="color:#f92672">&gt;&amp;</span> msg0,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Driver<span style="color:#f92672">&gt;&amp;</span> msg1) <span style="color:#66d9ef">override</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>CYBER_REGISTER_COMPONENT(CommonComponentSample)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JSON" data-lang="JSON"><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">components</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">class_name</span> <span style="color:#960050;background-color:#1e0010">:</span> <span style="color:#f92672">&#34;CommonComponentSample&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#960050;background-color:#1e0010">config</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">name</span> <span style="color:#960050;background-color:#1e0010">:</span> <span style="color:#f92672">&#34;common&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">readers</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">channel:</span> <span style="color:#f92672">&#34;/apollo/prediction&#34;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#960050;background-color:#1e0010">readers</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#960050;background-color:#1e0010">channel:</span> <span style="color:#f92672">&#34;/apollo/test&#34;</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div></li>
</ul>
<h4 id="时间驱动任务-timercomponent">
  时间驱动任务 TimerComponent
  <a class="anchor" href="#%e6%97%b6%e9%97%b4%e9%a9%b1%e5%8a%a8%e4%bb%bb%e5%8a%a1-timercomponent">#</a>
</h4>
<ul>
<li>
<p>代码中实现定时处理逻辑</p>
</li>
<li>
<p>配置文件中指定周期</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TimerComponentSample</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> TimerComponent {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> Init() <span style="color:#66d9ef">override</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Proc</span>() <span style="color:#66d9ef">override</span>;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>CYBER_REGISTER_COMPONENT(TimerComponentSample)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    timer_components {
</span></span><span style="display:flex;"><span>        class_name : <span style="color:#e6db74">&#34;TimerComponentSample&#34;</span>
</span></span><span style="display:flex;"><span>        config {
</span></span><span style="display:flex;"><span>            name : <span style="color:#e6db74">&#34;timer&#34;</span>
</span></span><span style="display:flex;"><span>            interval : <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div></li>
</ul>
<h4 id="reader-callback">
  Reader Callback
  <a class="anchor" href="#reader-callback">#</a>
</h4>
<ul>
<li>
<p>Component 由 CyberRT 框架代替用户创建数据 Reader</p>
</li>
<li>
<p>用户也可以自己手动创建 Reader，并指定收到数据后的 callback</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// init cyber framework
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  apollo<span style="color:#f92672">::</span>cyber<span style="color:#f92672">::</span>Init(argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// create listener node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> listener_node <span style="color:#f92672">=</span> apollo<span style="color:#f92672">::</span>cyber<span style="color:#f92672">::</span>CreateNode(<span style="color:#e6db74">&#34;listener&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// create listener
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> listener <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      listener_node<span style="color:#f92672">-&gt;</span>CreateReader<span style="color:#f92672">&lt;</span>apollo<span style="color:#f92672">::</span>cyber<span style="color:#f92672">::</span>examples<span style="color:#f92672">::</span>proto<span style="color:#f92672">::</span>Chatter<span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;channel/chatter&#34;</span>, MessageCallback);
</span></span><span style="display:flex;"><span>  apollo<span style="color:#f92672">::</span>cyber<span style="color:#f92672">::</span>WaitForShutdown();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h4 id="异步任务-async">
  异步任务 Async
  <a class="anchor" href="#%e5%bc%82%e6%ad%a5%e4%bb%bb%e5%8a%a1-async">#</a>
</h4>
<ul>
<li>
<p>对于一些自定义任务，也可以通过 cyber::Async 异步提交到调度器中运行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;cyber/cyber.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// init cyber framework
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  apollo<span style="color:#f92672">::</span>cyber<span style="color:#f92672">::</span>Init(argv[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> future <span style="color:#f92672">=</span> apollo<span style="color:#f92672">::</span>cyber<span style="color:#f92672">::</span>Async([] {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;async&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  apollo<span style="color:#f92672">::</span>cyber<span style="color:#f92672">::</span>WaitForShutdown();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h3 id="任务图搭建">
  任务图搭建
  <a class="anchor" href="#%e4%bb%bb%e5%8a%a1%e5%9b%be%e6%90%ad%e5%bb%ba">#</a>
</h3>
<p>通过 channel name 进行匹配组网，具体 topo 部分没细看</p>
<p>主要介绍一下数据同步的方式</p>
<h4 id="数据同步策略-all-latest">
  数据同步策略 all latest
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%90%8c%e6%ad%a5%e7%ad%96%e7%95%a5-all-latest">#</a>
</h4>
<ul>
<li>第一个 channel 作为触发源，每次收到 channel 0 的消息时，检查其余 channel 是否收到过消息
<ul>
<li>如果其他 channel 都曾经收到过，取最新的一个组合成一组，传给用户</li>
<li>否则丢弃</li>
</ul>
</li>
<li>触发 channel 的消息用完就消耗掉了</li>
<li>其他 channel 的消息会重复利用</li>
</ul>
<h3 id="调度">
  调度
  <a class="anchor" href="#%e8%b0%83%e5%ba%a6">#</a>
</h3>
<p>cyber 提供两种调度策略，Classic 和 Choreography</p>
<h4 id="调度策略">
  调度策略
  <a class="anchor" href="#%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5">#</a>
</h4>
<h5 id="classicscheduler">
  ClassicScheduler
  <a class="anchor" href="#classicscheduler">#</a>
</h5>
<p><img src="assets/2024-07-24%20CyberRT%e8%b0%83%e5%ba%a6%e8%b0%83%e7%a0%94@6586b725-7ce4-4074-aac5-ccb1f2910719.png" alt="|927" /></p>
<pre><code>- 多组线程池，默认是一组

    - 支持为整组线程池设定同一个linux调度策略；绑核支持range / 1to1 两种方式；

- 每组线程池共享N个不同优先级的任务队列

    - 依次从高优先级队列到低优先级队列查找ready的任务

    - 同一个优先级队列中，根据任务创建顺序遍历，有就绪的任务就执行

- 任务可以指定 所在组、优先级
</code></pre>
<ul>
<li>
<p>调度策略</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CRoutine<span style="color:#f92672">&gt;</span> ClassicContext<span style="color:#f92672">::</span>NextRoutine() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (cyber_unlikely(stop_.load())) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> MAX_PRIO <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>i) {
</span></span><span style="display:flex;"><span>    ReadLockGuard<span style="color:#f92672">&lt;</span>AtomicRWLock<span style="color:#f92672">&gt;</span> lk(lq_<span style="color:#f92672">-&gt;</span>at(i));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> cr : multi_pri_rq_<span style="color:#f92672">-&gt;</span>at(i)) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cr<span style="color:#f92672">-&gt;</span>Acquire()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (cr<span style="color:#f92672">-&gt;</span>UpdateState() <span style="color:#f92672">==</span> RoutineState<span style="color:#f92672">::</span>READY) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> cr;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      cr<span style="color:#f92672">-&gt;</span>Release();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>调度配置文件示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>scheduler_conf {
</span></span><span style="display:flex;"><span>  policy: <span style="color:#e6db74">&#34;classic&#34;</span>
</span></span><span style="display:flex;"><span>  classic_conf {
</span></span><span style="display:flex;"><span>    groups: [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        name: <span style="color:#e6db74">&#34;compute&#34;</span>
</span></span><span style="display:flex;"><span>        processor_num: <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>        affinity: <span style="color:#e6db74">&#34;range&#34;</span>
</span></span><span style="display:flex;"><span>        cpuset: <span style="color:#e6db74">&#34;0-7,16-23&#34;</span>
</span></span><span style="display:flex;"><span>        processor_policy: <span style="color:#e6db74">&#34;SCHED_OTHER&#34;</span>
</span></span><span style="display:flex;"><span>        processor_prio: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        tasks: [
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            name: <span style="color:#e6db74">&#34;velodyne_16_front_center_convert&#34;</span>
</span></span><span style="display:flex;"><span>            prio: <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>          },
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            name: <span style="color:#e6db74">&#34;msf_localization_/apollo/sensor/lidar64/compensator/PointCloud2&#34;</span>
</span></span><span style="display:flex;"><span>            prio: <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        ]
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        name: <span style="color:#e6db74">&#34;compute_camera&#34;</span>
</span></span><span style="display:flex;"><span>        processor_num: <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>        affinity: <span style="color:#e6db74">&#34;range&#34;</span>
</span></span><span style="display:flex;"><span>        cpuset: <span style="color:#e6db74">&#34;8-15,24-31&#34;</span>
</span></span><span style="display:flex;"><span>        processor_policy: <span style="color:#e6db74">&#34;SCHED_OTHER&#34;</span>
</span></span><span style="display:flex;"><span>        processor_prio: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        tasks: [
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            name: <span style="color:#e6db74">&#34;camera_front_6mm_compress&#34;</span>
</span></span><span style="display:flex;"><span>            prio: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>          },
</span></span><span style="display:flex;"><span>          {
</span></span><span style="display:flex;"><span>            name: <span style="color:#e6db74">&#34;camera_rear_6mm_compress&#34;</span>
</span></span><span style="display:flex;"><span>            prio: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        ]
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h5 id="choreographyscheduler">
  ChoreographyScheduler
  <a class="anchor" href="#choreographyscheduler">#</a>
</h5>
<p><img src="assets/2024-07-24%20CyberRT%e8%b0%83%e5%ba%a6%e8%b0%83%e7%a0%94@bb6549f9-6ffe-4ae7-894d-f304fd3ce460.png" alt="" /></p>
<pre><code>- N个choreography线程 + 一组classic线程池

    - 调度策略设置上，所有choreography线程相当于一组，可以设定同一个调度策略，绑核支持 range / 1to1 两种方式

- 任务队列

    - 每个choreography线程有一个优先级队列（multimap），按照迭代器顺序遍历，有就绪的任务就执行

    - classic线程池和ClassicScheduler相同，但只有一组

- 任务可以指定 所在线程/组、优先级
</code></pre>
<ul>
<li>
<p>调度策略</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>CRoutine<span style="color:#f92672">&gt;</span> ChoreographyContext<span style="color:#f92672">::</span>NextRoutine() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (cyber_unlikely(stop_.load())) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ReadLockGuard<span style="color:#f92672">&lt;</span>AtomicRWLock<span style="color:#f92672">&gt;</span> lock(rq_lk_);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> it : cr_queue_) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> cr <span style="color:#f92672">=</span> it.second;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>cr<span style="color:#f92672">-&gt;</span>Acquire()) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cr<span style="color:#f92672">-&gt;</span>UpdateState() <span style="color:#f92672">==</span> RoutineState<span style="color:#f92672">::</span>READY) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> cr;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cr<span style="color:#f92672">-&gt;</span>Release();
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>调度配置文件示例</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>scheduler_conf {
</span></span><span style="display:flex;"><span>  policy: <span style="color:#e6db74">&#34;choreography&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  choreography_conf {
</span></span><span style="display:flex;"><span>    choreography_processor_num: <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>    choreography_affinity: <span style="color:#e6db74">&#34;range&#34;</span>
</span></span><span style="display:flex;"><span>    choreography_cpuset: <span style="color:#e6db74">&#34;0-7&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pool_processor_num: <span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>    pool_affinity: <span style="color:#e6db74">&#34;range&#34;</span>
</span></span><span style="display:flex;"><span>    pool_cpuset: <span style="color:#e6db74">&#34;8-11,16-23&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    tasks: [
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        name: <span style="color:#e6db74">&#34;planning_/apollo/perception/traffic_light&#34;</span>
</span></span><span style="display:flex;"><span>        processor: <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>        prio: <span style="color:#ae81ff">17</span>
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        name: <span style="color:#e6db74">&#34;rtk_localization&#34;</span>
</span></span><span style="display:flex;"><span>        processor: <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        name: <span style="color:#e6db74">&#34;camera_rear_6mm_compress&#34;</span>
</span></span><span style="display:flex;"><span>        prio: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h2 id="processor">
  Processor
  <a class="anchor" href="#processor">#</a>
</h2>
<ul>
<li>
<p>取下一个 ready 的协程任务并执行</p>
</li>
<li>
<p>没有任务就等待</p>
</li>
<li>
<p>code</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Processor<span style="color:#f92672">::</span>Run() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (cyber_likely(running_.load())) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cyber_likely(context_ <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>)) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">auto</span> croutine <span style="color:#f92672">=</span> context_<span style="color:#f92672">-&gt;</span>NextRoutine();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (croutine) {
</span></span><span style="display:flex;"><span>        snap_shot_<span style="color:#f92672">-&gt;</span>execute_start_time.store(cyber<span style="color:#f92672">::</span>Time<span style="color:#f92672">::</span>Now().ToNanosecond());
</span></span><span style="display:flex;"><span>        snap_shot_<span style="color:#f92672">-&gt;</span>routine_name <span style="color:#f92672">=</span> croutine<span style="color:#f92672">-&gt;</span>name();
</span></span><span style="display:flex;"><span>        croutine<span style="color:#f92672">-&gt;</span>Resume();
</span></span><span style="display:flex;"><span>        croutine<span style="color:#f92672">-&gt;</span>Release();
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        snap_shot_<span style="color:#f92672">-&gt;</span>execute_start_time.store(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        context_<span style="color:#f92672">-&gt;</span>Wait();
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h3 id="协程">
  协程
  <a class="anchor" href="#%e5%8d%8f%e7%a8%8b">#</a>
</h3>
<ul>
<li>
<p>从执行效率角度，可能和普通线程池没有太大差别</p>
<ul>
<li>
<p>每个 component 对应的协程，生命周期和 component 相同，不需要频繁动态创建和销毁</p>
</li>
<li>
<p>协程的 context 用了一个全局的对象池，减少动态内存分配</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>CRoutine<span style="color:#f92672">::</span>CRoutine(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>func) <span style="color:#f92672">:</span> func_(func) {
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>call_once(pool_init_flag, [<span style="color:#f92672">&amp;</span>]() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    context_pool.reset(<span style="color:#66d9ef">new</span> base<span style="color:#f92672">::</span>CCObjectPool<span style="color:#f92672">&lt;</span>RoutineContext<span style="color:#f92672">&gt;</span>(routine_num));
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  context_ <span style="color:#f92672">=</span> context_pool<span style="color:#f92672">-&gt;</span>GetObject();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (context_ <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>    AWARN <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Maximum routine context number exceeded! Please check &#34;</span>
</span></span><span style="display:flex;"><span>             <span style="color:#e6db74">&#34;[routine_num] in config file.&#34;</span>;
</span></span><span style="display:flex;"><span>    context_.reset(<span style="color:#66d9ef">new</span> RoutineContext());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  MakeContext(CRoutineEntry, <span style="color:#66d9ef">this</span>, context_.get());
</span></span><span style="display:flex;"><span>  state_ <span style="color:#f92672">=</span> RoutineState<span style="color:#f92672">::</span>READY;
</span></span><span style="display:flex;"><span>  updated_.test_and_set(std<span style="color:#f92672">::</span>memory_order_release);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>感觉更多的好处是编码方便：同步编码，异步执行：阻塞逻辑只会挂起协程自身，不会阻塞整个线程</p>
<ul>
<li>
<p>sleep</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 用户sleep接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">USleep</span>(useconds_t usec) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> routine <span style="color:#f92672">=</span> croutine<span style="color:#f92672">::</span>CRoutine<span style="color:#f92672">::</span>GetCurrentRoutine();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (routine <span style="color:#f92672">==</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>microseconds{usec});
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    routine<span style="color:#f92672">-&gt;</span>Sleep(croutine<span style="color:#f92672">::</span>Duration(usec));
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CRoutine sleep
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> CRoutine<span style="color:#f92672">::</span>Sleep(<span style="color:#66d9ef">const</span> Duration <span style="color:#f92672">&amp;</span>sleep_duration) {
</span></span><span style="display:flex;"><span>  wake_time_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now() <span style="color:#f92672">+</span> sleep_duration;
</span></span><span style="display:flex;"><span>  CRoutine<span style="color:#f92672">::</span>Yield(RoutineState<span style="color:#f92672">::</span>SLEEP);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CRoutine wakeup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> RoutineState CRoutine<span style="color:#f92672">::</span>UpdateState() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Synchronous Event Mechanism
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (state_ <span style="color:#f92672">==</span> RoutineState<span style="color:#f92672">::</span>SLEEP <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now() <span style="color:#f92672">&gt;</span> wake_time_) {
</span></span><span style="display:flex;"><span>    state_ <span style="color:#f92672">=</span> RoutineState<span style="color:#f92672">::</span>READY;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> state_;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Asynchronous Event Mechanism
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>updated_.test_and_set(std<span style="color:#f92672">::</span>memory_order_release)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (state_ <span style="color:#f92672">==</span> RoutineState<span style="color:#f92672">::</span>DATA_WAIT <span style="color:#f92672">||</span> state_ <span style="color:#f92672">==</span> RoutineState<span style="color:#f92672">::</span>IO_WAIT) {
</span></span><span style="display:flex;"><span>      state_ <span style="color:#f92672">=</span> RoutineState<span style="color:#f92672">::</span>READY;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> state_;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>io wait / data wait</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// yield
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> CRoutine<span style="color:#f92672">::</span>Yield(<span style="color:#66d9ef">const</span> RoutineState <span style="color:#f92672">&amp;</span>state) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> routine <span style="color:#f92672">=</span> GetCurrentRoutine();
</span></span><span style="display:flex;"><span>  routine<span style="color:#f92672">-&gt;</span>set_state(state);
</span></span><span style="display:flex;"><span>  SwapContext(GetCurrentRoutine()<span style="color:#f92672">-&gt;</span>GetStack(), GetMainStack());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> CRoutine<span style="color:#f92672">::</span>Yield() {
</span></span><span style="display:flex;"><span>  SwapContext(GetCurrentRoutine()<span style="color:#f92672">-&gt;</span>GetStack(), GetMainStack());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// update
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> CRoutine<span style="color:#f92672">::</span>SetUpdateFlag() {
</span></span><span style="display:flex;"><span>  updated_.clear(std<span style="color:#f92672">::</span>memory_order_release);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>状态机</p>
</li>
</ul>
</li>
</ul>
<p><img src="assets/2024-07-24%20CyberRT%e8%b0%83%e5%ba%a6%e8%b0%83%e7%a0%94@7d382f7a-7e19-4726-a01b-91e497ef2e15.png" alt="|722" /></p>
<ul>
<li>
<p>示例：poll_handler</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Echo</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>Session<span style="color:#f92672">&gt;&amp;</span> session) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr_in</span> client_addr;
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> recv_buffer(<span style="color:#ae81ff">2049</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> nbytes <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  socklen_t sock_len <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>socklen_t<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">sizeof</span>(client_addr));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (true) {
</span></span><span style="display:flex;"><span>    nbytes <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>        session<span style="color:#f92672">-&gt;</span>RecvFrom(recv_buffer.data(), recv_buffer.size(), <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>                          (<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>client_addr, <span style="color:#f92672">&amp;</span>sock_len));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (nbytes <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;recv from client failed.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    session<span style="color:#f92672">-&gt;</span>SendTo(recv_buffer.data(), nbytes, <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>                    (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sockaddr</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>client_addr, sock_len);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> PollHandler<span style="color:#f92672">::</span>Block(<span style="color:#66d9ef">int</span> timeout_ms, <span style="color:#66d9ef">bool</span> is_read) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Fill(timeout_ms, is_read);  <span style="color:#75715e">// 注册回调
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 挂起协程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  routine_<span style="color:#f92672">-&gt;</span>Yield(RoutineState<span style="color:#f92672">::</span>IO_WAIT);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> PollHandler<span style="color:#f92672">::</span>Fill(<span style="color:#66d9ef">int</span> timeout_ms, <span style="color:#66d9ef">bool</span> is_read) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 注册回调
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  request_.callback <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>bind(<span style="color:#f92672">&amp;</span>PollHandler<span style="color:#f92672">::</span>ResponseCallback, <span style="color:#66d9ef">this</span>, std<span style="color:#f92672">::</span>placeholders<span style="color:#f92672">::</span>_1);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> PollHandler<span style="color:#f92672">::</span>ResponseCallback(<span style="color:#66d9ef">const</span> PollResponse<span style="color:#f92672">&amp;</span> rsp) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (routine_<span style="color:#f92672">-&gt;</span>state() <span style="color:#f92672">==</span> RoutineState<span style="color:#f92672">::</span>IO_WAIT) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 回调中让调度器更新协程状态        
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    scheduler<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>NotifyTask(routine_<span style="color:#f92672">-&gt;</span>id());  
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*                     NotifyTask
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                             -&gt; NotifyProcessor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">                               -&gt; cr-&gt;SetUpdateFlag();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h3 id="任务对应的协程">
  任务对应的协程
  <a class="anchor" href="#%e4%bb%bb%e5%8a%a1%e5%af%b9%e5%ba%94%e7%9a%84%e5%8d%8f%e7%a8%8b">#</a>
</h3>
<h4 id="数据驱动任务">
  数据驱动任务
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%e4%bb%bb%e5%8a%a1">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>M0<span style="color:#f92672">&gt;</span> msg0;
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>M1<span style="color:#f92672">&gt;</span> msg1;
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>M2<span style="color:#f92672">&gt;</span> msg2;
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>M3<span style="color:#f92672">&gt;</span> msg3;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>        CRoutine<span style="color:#f92672">::</span>GetCurrentRoutine()<span style="color:#f92672">-&gt;</span>set_state(RoutineState<span style="color:#f92672">::</span>DATA_WAIT);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dv<span style="color:#f92672">-&gt;</span>TryFetch(msg0, msg1, msg2, msg3)) {
</span></span><span style="display:flex;"><span>          f(msg0, msg1, msg2, msg3);
</span></span><span style="display:flex;"><span>          CRoutine<span style="color:#f92672">::</span>Yield(RoutineState<span style="color:#f92672">::</span>READY);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>          CRoutine<span style="color:#f92672">::</span>Yield();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span></code></pre></div><h4 id="时间驱动任务--异步任务">
  时间驱动任务 &amp; 异步任务
  <a class="anchor" href="#%e6%97%b6%e9%97%b4%e9%a9%b1%e5%8a%a8%e4%bb%bb%e5%8a%a1--%e5%bc%82%e6%ad%a5%e4%bb%bb%e5%8a%a1">#</a>
</h4>
<p><img src="assets/2024-07-24%20CyberRT%e8%b0%83%e5%ba%a6%e8%b0%83%e7%a0%94@6f1f4cc0-8881-46f6-b181-acaacb7c447a.png" alt="|763" /></p>
<ul>
<li>
<p>cyberRT 中有一个全局的协程池，TaskManager；</p>
<ul>
<li>
<p>TaskManager 会往调度器里添加 N 个 CRoutine 任务（/internal/task0、…、/internal/taskx），实际由调度器进行调度执行</p>
</li>
<li>
<p>TaskManager 中每个协程的任务是从任务队列中取任务并执行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>TaskManager<span style="color:#f92672">::</span>TaskManager()
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> task_queue_size_(<span style="color:#ae81ff">1000</span>),
</span></span><span style="display:flex;"><span>      task_queue_(<span style="color:#66d9ef">new</span> base<span style="color:#f92672">::</span>BoundedQueue<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;&gt;</span>()) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> func <span style="color:#f92672">=</span> [<span style="color:#66d9ef">this</span>]() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>stop_) {
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;</span> task;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>task_queue_<span style="color:#f92672">-&gt;</span>Dequeue(<span style="color:#f92672">&amp;</span>task)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> routine <span style="color:#f92672">=</span> croutine<span style="color:#f92672">::</span>CRoutine<span style="color:#f92672">::</span>GetCurrentRoutine();
</span></span><span style="display:flex;"><span>        routine<span style="color:#f92672">-&gt;</span>HangUp();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      task();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  num_threads_ <span style="color:#f92672">=</span> scheduler<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>TaskPoolSize();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> factory <span style="color:#f92672">=</span> croutine<span style="color:#f92672">::</span>CreateRoutineFactory(std<span style="color:#f92672">::</span>move(func));
</span></span><span style="display:flex;"><span>  tasks_.reserve(num_threads_);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint32_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> num_threads_; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> task_name <span style="color:#f92672">=</span> task_prefix <span style="color:#f92672">+</span> std<span style="color:#f92672">::</span>to_string(i);
</span></span><span style="display:flex;"><span>    tasks_.push_back(common<span style="color:#f92672">::</span>GlobalData<span style="color:#f92672">::</span>RegisterTaskName(task_name));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>scheduler<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>CreateTask(factory, task_name)) {
</span></span><span style="display:flex;"><span>      AERROR <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;CreateTask failed:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> task_name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p>Async 会把任务加进协程池的任务队列</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> F, <span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">auto</span> Async(F<span style="color:#f92672">&amp;&amp;</span> f, Args<span style="color:#f92672">&amp;&amp;</span>... args)
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>result_of<span style="color:#f92672">&lt;</span>F(Args...)<span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> GlobalData<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>IsRealityMode()
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">?</span> TaskManager<span style="color:#f92672">::</span>Instance()<span style="color:#f92672">-&gt;</span>Enqueue(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span>(f),
</span></span><span style="display:flex;"><span>                                                std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>Args<span style="color:#f92672">&gt;</span>(args)...)
</span></span><span style="display:flex;"><span>             <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>async(
</span></span><span style="display:flex;"><span>                   std<span style="color:#f92672">::</span>launch<span style="color:#f92672">::</span>async,
</span></span><span style="display:flex;"><span>                   std<span style="color:#f92672">::</span>bind(std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span>(f), std<span style="color:#f92672">::</span>forward<span style="color:#f92672">&lt;</span>Args<span style="color:#f92672">&gt;</span>(args)...));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>时间驱动任务额外维护一个时间轮线程，时间轮线程负责定时调用 Async</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>tick_thread_ <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>([<span style="color:#66d9ef">this</span>]() { <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>TickFunc(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">void</span> TimingWheel<span style="color:#f92672">::</span>TickFunc() {
</span></span><span style="display:flex;"><span>  Rate <span style="color:#a6e22e">rate</span>(TIMER_RESOLUTION_MS <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000000</span>);  <span style="color:#75715e">// ms to ns
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span> (running_) {
</span></span><span style="display:flex;"><span>    Tick();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    rate.Sleep();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> TimingWheel<span style="color:#f92672">::</span>Tick() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> bucket <span style="color:#f92672">=</span> work_wheel_[current_work_wheel_index_];
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(bucket.mutex());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">auto</span> ite <span style="color:#f92672">=</span> bucket.task_list().begin();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (ite <span style="color:#f92672">!=</span> bucket.task_list().end()) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">auto</span> task <span style="color:#f92672">=</span> ite<span style="color:#f92672">-&gt;</span>lock();
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (task) {
</span></span><span style="display:flex;"><span>        ADEBUG <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;index: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> current_work_wheel_index_
</span></span><span style="display:flex;"><span>               <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; timer id: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> task<span style="color:#f92672">-&gt;</span>timer_id_;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span><span style="color:#f92672">*</span> callback <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>()<span style="color:#f92672">&gt;*&gt;</span>(<span style="color:#f92672">&amp;</span>(task<span style="color:#f92672">-&gt;</span>callback));
</span></span><span style="display:flex;"><span>        cyber<span style="color:#f92672">::</span>Async([<span style="color:#66d9ef">this</span>, callback] {
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>running_) {
</span></span><span style="display:flex;"><span>            (<span style="color:#f92672">*</span>callback)();
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      ite <span style="color:#f92672">=</span> bucket.task_list().erase(ite);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ul>
<h4 id="reader">
  reader
  <a class="anchor" href="#reader">#</a>
</h4>
<ul>
<li>每个 reader 会对应一个 CRoutine 任务</li>
<li>如果用户创建 Reader 时指定了 callback，会在这个协程任务中取数据并执行 callback
<ul>
<li>callback 在 croutine 的上下文执行，通信线程只负责通知</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> MessageT<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> Reader<span style="color:#f92672">&lt;</span>MessageT<span style="color:#f92672">&gt;::</span>Init() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>(<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>MessageT<span style="color:#f92672">&gt;&amp;</span>)<span style="color:#f92672">&gt;</span> func;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (reader_func_ <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>) {
</span></span><span style="display:flex;"><span>    func <span style="color:#f92672">=</span> [<span style="color:#66d9ef">this</span>](<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>MessageT<span style="color:#f92672">&gt;&amp;</span> msg) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>Enqueue(msg);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>reader_func_(msg);
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    func <span style="color:#f92672">=</span> [<span style="color:#66d9ef">this</span>](<span style="color:#66d9ef">const</span> std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>MessageT<span style="color:#f92672">&gt;&amp;</span> msg) { <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>Enqueue(msg); };
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">auto</span> sched <span style="color:#f92672">=</span> scheduler<span style="color:#f92672">::</span>Instance();
</span></span><span style="display:flex;"><span>  croutine_name_ <span style="color:#f92672">=</span> role_attr_.node_name() <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;_&#34;</span> <span style="color:#f92672">+</span> role_attr_.channel_name();
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>sched<span style="color:#f92672">-&gt;</span>CreateTask(factory, croutine_name_)) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="scheduler-相关代码结构">
  scheduler 相关代码结构
  <a class="anchor" href="#scheduler-%e7%9b%b8%e5%85%b3%e4%bb%a3%e7%a0%81%e7%bb%93%e6%9e%84">#</a>
</h2>
<ul>
<li>
<p>初始化大致流程</p>
<p><img src="assets/2024-07-24%20CyberRT%e8%b0%83%e5%ba%a6%e8%b0%83%e7%a0%94@196c4d17-d7e6-4442-a5f6-194b25d67f9c.png" alt="" /></p>
</li>
</ul>
<h2 id="附录">
  附录
  <a class="anchor" href="#%e9%99%84%e5%bd%95">#</a>
</h2>
<h3 id="线程情况">
  线程情况
  <a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%83%85%e5%86%b5">#</a>
</h3>
<p><img src="assets/2024-07-24%20CyberRT%e8%b0%83%e5%ba%a6%e8%b0%83%e7%a0%94@a5c4a06a-2d42-4914-bb44-3a1c1df37a2e.png" alt="" /></p>
<ul>
<li>1: 主线程</li>
<li>2: 异步 log 线程 async logger</li>
<li>3-18: 调度器线程：执行 CRoutine 的线程池，数量取决于配置文件，默认等于 core 数量</li>
<li>19-24: fastrtps 相关线程
<ul>
<li>19: eprosima::fastrtps::rtps::UDPv4Transport</li>
<li>20: eprosima::fastrtps::rtps::ResourceEvent::run_io_service</li>
<li>21: eprosima::fastrtps::rtps::ReceiverResource::Receive</li>
<li>22: eprosima::fastrtps::rtps::UDPv4Transport::Receive</li>
<li>23: eprosima::fastrtps::rtps::UDPv4Transport::Receive</li>
<li>24: eprosima::fastrtps::rtps::AsyncWriterThread::run</li>
</ul>
</li>
<li>25: 共享内存线程 apollo::cyber::transport::ShmDispatcher::ThreadFunc()</li>
<li>26: 时间轮线程 apollo::cyber::TimingWheel::TickFunc()</li>
</ul>
<h3 id="和-mediapipetaskflow-对比">
  和 mediapipe、Taskflow 对比
  <a class="anchor" href="#%e5%92%8c-mediapipetaskflow-%e5%af%b9%e6%af%94">#</a>
</h3>
<ul>
<li>DAG 搭建
<ul>
<li>数据同步方式：mediapipe 更灵活，种类更多</li>
</ul>
</li>
<li>调度：
<ul>
<li>cyber 调度策略更灵活，支持自定义任务优先级；</li>
<li>mediapipe 支持定制执行器，但不支持定制调度策略；可以通过分组实现和 cyber 类似的效果</li>
</ul>
</li>
<li>通信：cyber 支持跨进程</li>
<li>具体线程池的实现上，也许可以参考 Taskflow</li>
</ul>
<h3 id="reference">
  reference
  <a class="anchor" href="#reference">#</a>
</h3>
<ul>
<li>cyber rt 协程具体实现的解析：
<ul>
<li><a href="https://blog.csdn.net/jinzhuojun/article/details/86760743">https://blog.csdn.net/jinzhuojun/article/details/86760743</a></li>
<li><a href="https://blog.csdn.net/lizhipengcsdn/article/details/131236278">https://blog.csdn.net/lizhipengcsdn/article/details/131236278</a></li>
</ul>
</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#背景需求目的">背景&amp;需求&amp;目的</a></li>
    <li><a href="#方案">方案</a>
      <ul>
        <li><a href="#用户接口任务类型">用户接口（任务类型）</a></li>
        <li><a href="#任务图搭建">任务图搭建</a></li>
        <li><a href="#调度">调度</a></li>
      </ul>
    </li>
    <li><a href="#processor">Processor</a>
      <ul>
        <li><a href="#协程">协程</a></li>
        <li><a href="#任务对应的协程">任务对应的协程</a></li>
      </ul>
    </li>
    <li><a href="#scheduler-相关代码结构">scheduler 相关代码结构</a></li>
    <li><a href="#附录">附录</a>
      <ul>
        <li><a href="#线程情况">线程情况</a></li>
        <li><a href="#和-mediapipetaskflow-对比">和 mediapipe、Taskflow 对比</a></li>
        <li><a href="#reference">reference</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












