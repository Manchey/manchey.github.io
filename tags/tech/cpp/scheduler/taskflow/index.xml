<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech/Cpp/Scheduler/Taskflow on Manchey Blog</title>
    <link>http://localhost:1313/tags/tech/cpp/scheduler/taskflow/</link>
    <description>Recent content in Tech/Cpp/Scheduler/Taskflow on Manchey Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>© Manchey Lee 2024</copyright>
    <lastBuildDate>Thu, 12 Dec 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/tech/cpp/scheduler/taskflow/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Taskflow如何工作</title>
      <link>http://localhost:1313/posts/2024/12/taskflow%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</link>
      <pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/2024/12/taskflow%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</guid>
      <description>&lt;h2 id=&#34;运行机制&#34;&gt;&#xA;  运行机制&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;executor&#34;&gt;&#xA;  Executor&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#executor&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;构造函数，可以看出来它的成员：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;N 个线程&lt;/li&gt;&#xA;&lt;li&gt;N 个 Worker，每个 Worker 一个线程&lt;/li&gt;&#xA;&lt;li&gt;Notifier，负责线程之间通知的&lt;/li&gt;&#xA;&lt;li&gt;Latch，负责主线程和 Worker 线程的初始化的同步的&lt;/li&gt;&#xA;&lt;li&gt;FreeList，一个有锁队列，主线程提交任务时就会往这里填充，或者 Worker 线程提交任务时，发现 Worker 自己的队列满了就往 FreeList 提交&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@e9a1f7b6-7efa-4839-8e6d-f4cf815545dc.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Executor 的构造函数中初始化了 thread local 的 Worker，创建 N 个线程，每个线程是一个 while(1)，等待 task、执行 task。&lt;/p&gt;&#xA;&lt;p&gt;Executor::Executor(size_t N) -》_spawn(N)：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@e73c0e09-2f76-420e-8348-680d212f3345.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;assets/2024-12-12%20Taskflow%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c@93169a2e-e0cf-4880-94ea-7669e182048d.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;Executor 也是有两级的链表：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;第一级是 Executor 会有以及，它是无界、lock-free 队列（Push 有锁，但是 Steal 是无锁的，也就是说适合单生产者 - 多消费者场景）：Freelist&amp;lt;Node*&amp;gt; _freelist;&lt;/li&gt;&#xA;&lt;li&gt;第二级是每个 Worker 都有一个有界的、lock-free 队列：BoundedTaskQueue&amp;lt;Node*&amp;gt; _wsq;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Executor 的 run 函数，会将没有 depends 的 node 直接放入到 freelist 中，这样整个 graph 就可以运转起来了：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
